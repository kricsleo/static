<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title></title>
  <link rel="stylesheet" href="https://oss.kricsleo.com/github.min.css" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="article">
    <div class="sidebar">
      <img src="https://oss.kricsleo.com/avatar.jpg" class="sidebar__avatar">
      <input class="sidebar__input" id="sidebar__input" type="text" placeholder="type something" autofocus>
      <ul class="sidebar__input-result" id="sidebar__input-result"></ul>
      <p class="sidebar__copyright">
        @<a href="/">kricleo.com</a>
      </p>
    </div>
    <div class="article__wrapper">
      <div class="article__viewport">
        <div class="article__content">
          <h1>typescript</h1>
<p>以前的ts笔记不知道去哪了, 心痛, 重新整理写一下吧</p>
<p>发现一个写的很详细的ts中文文档:<a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></p>
<h2>部分“神奇参数“</h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<p>esModuleInterop: boolean</p>
<p><a href="https://zhuanlan.zhihu.com/p/148081795">esModuleInterop 到底做了什么？</a></p>
<p>简单来说是由于CommonJS和ES module对于默认导出导入的逻辑不一致, 所以在使用ts把ES module模块代码编译成CommonJS模块代码时需要进行的一个特殊处理, 这个参数影响的是ts对于<code>import</code>的转译规则(<code>export</code>不受影响)</p>
<p>babel 默认的转译规则和 TS 开启 esModuleInterop 的情况差不多, 所以如果旧代码是使用babel打包的, 那么大概率你在切换到ts打包后需要手动开启这个参数</p>
<p>对于默认如下导入</p>
<pre><code class="language-typescript">// 注意 React 的声明文件本身没有默认导出, 都是 exports.Children = Children 这样的导出方式
// 在js中我们可以直接使用下面的默认导出, 会把所有属性都挂载到这个对象上
// 但是在ts中没有默认导出的时候, 我们应该使用 import * as React from 'react' 的方法来达到js中同样的效果
// 这里在ts仍然使用js的导入方法只是为了演示会导致什么样的结果, 以及开启 esModuleInterop 参数后就可以&quot;修复&quot;这种行为
import React from 'react';
console.log(React);

// 转译后
// esModuleInterop: fasle (默认值) 
&quot;use strict&quot;;
exports.__esModule = true;
var react_1 = require(&quot;react&quot;);
// 这里实际会打印出 undefined , 因为 React 没有默认导出(default)
console.log(react_1[&quot;default&quot;]);

// esModuleInterop: true
// (代码经过简化, 主要是使用默认导出的地方会包上一层 __importDefault 处理 default 属性的调用)
var __importDefault = function (mod) {
  return mod &amp;&amp; mod.__esModule ? mod : { default: mod };
};
 var react = __importDefault(require('react'));
// 这里可以正常打印结果, 因为 __importDefault 手动把所有属性挂载到了 default 上达到了babel一样的效果
 console.log(react['default']);
</code></pre>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>moduleResolution: ‘node’ | ‘classic’</p>
<p>表示模块解析策略, 如果module配置是 commonjs 那么默认采用 node 解析策略, 如果module是其他值(<code>amd</code>, <code>system</code>, <code>umd</code>, <code>es2015</code>, <code>esnext</code>, etc.), 那么默认采用 classic, 使用 node 解析策略的较多, 因为用webpack 打包的时候是基于node模式, 所以 ts 配置为node更符合我们日常的认知和做法, 采取的两种解析模式的差别如下</p>
<pre><code>// 在源文件/root/src/A中导入一个模块, 两种解析方式查找文件方式不同
import { b } from &quot;./moduleB&quot;

// classic模块解析方式
1. /root/src/moduleB.ts
2. /root/src/moduleB.d.ts

// node模块解析方式
1. /root/src/moduleB.ts
2. /root/src/moduleB.tsx
3. /root/src/moduleB.d.ts
4. /root/src/moduleB/package.json (if it specifies a &quot;types&quot; property)
5. /root/src/moduleB/index.ts
6. /root/src/moduleB/index.tsx
7. /root/src/moduleB/index.d.ts
</code></pre>
</li>
</ul>

        </div>
      </div>
    </div>
  </div>
  <script src="https://oss.kricsleo.com/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <script src="index.js"></script>
</body>
</html>