{"path":"input-event","title":"input-event","summary":"input 元素的事件顺序h5 的<input />组件上有很多的事件, 这次来详细的探究一下它们的触发顺序和使用场景我的测试是在 chrome 版本 73.0.3683.75（正式版本）（64 位）","text":"input 元素的事件顺序h5 的<input />组件上有很多的事件, 这次来详细的探究一下它们的触发顺序和使用场景我的测试是在 chrome 版本 73.0.3683.75（正式版本）（64 位）环境, 其它的浏览器可能有不同, 有时间再补充其它浏览器吧.目前来说比较常用的有focus/keydown/input/keyup/compositionstart/compositionupdate/compositionend/change 点击一个输入框开始输入触发的事件顺序依次是: focus=>keydown(=>compositionstart=>compositionupdate)=>input(=>compositionend)=>keyup如果是组合输入(比如中文日文等)输入的话就会出现括号中组合输入事件, 详细来说是当开始输入中文的时候就会触发compositionstart事件, 此时input事件和keyup事件拿到的输入框的值是不完整的(一般包含你输入的拼音和拼音之间的分号), 当中文输入结束的时候会触发compositionend事件, 此时可以取到该输入框的完整的输入中文后的值(一般而言这个值是我们所需要的)(额外的一点是从input事件开始可以拿到最新输入的值, 前面的事件拿到的值都要落后一次, 少了最后一次输入的字符)change事件的触发需要两个条件, 一是input元素即将失焦, 事件顺序是change=>blur, 二是本次失焦后的内容与前一次失焦后的内容不同(如果相同是不会触发该事件的),最常用的场景之一是input用来搜索的时候, 我们的需求是输入变化的时候就去查询(当然有节流), 但是在中文输入的时候就不要查询, 直到中文输入结束之后再查询, 这样可以避免用一些明显无效的关键词如文章n'r去查询, 等到完整中文输入后变成文章内容再去查询function throttle(fn, minDelay, maxDelay) {\n  let timer;\n  let startTime = new Date();\n  return function () {\n    const context = this;\n    const args = arguments;\n    let curTime = new Date();\n    clearTimeout(timer);\n    if (curTime - startTime >= maxDelay) {\n      fn.apply(context, args);\n      startTime = curTime;\n    } else {\n      timer = setTimeout(() => {\n        fn.apply(context, args);\n      }, minDelay);\n    }\n  }\n}\n\nfunction listenInput(selector, cb, delay = 150, maxDelay = 1000) {\n  const el = document.querySelector(selector);\n  if(!el || !cb || typeof cb !== 'function') {\n    return false;\n  }\n  const throttleCB = throttle(cb, delay, maxDelay);\n  let isComposition = false;\n  const compositionstart = () => isComposition = true;\n  const compositionend = () => {\n    isComposition = false;\n    throttleCB(el.value);\n  };\n  const input = () => {\n    if(isComposition) {\n      return false;\n    }\n    throttleCB(el.value);\n  }\n\n  el.addEventListener('compositionstart', compositionstart);\n  el.addEventListener('compositionend', compositionend);\n  el.addEventListener('input', input);\n  \n  return () => {\n    el.removeEventListener('compositionstart', compositionstart);\n    el.removeEventListener('compositionend', compositionend);\n    el.removeEventListener('input', input);\n  }\n}\n\n// 使用示例\n// 开始监听, 默认最小间隔时间是150ms, 最大间隔时间是1000ms\nconst removeListener = listenInput('#inputId', value => {\n  console.log(value);\n}, 100, 1500);\n\n// 取消监听\nremoveListener();\n","html":"<h1>input 元素的事件顺序</h1>\n<p>h5 的<code>&lt;input /&gt;</code>组件上有很多的事件, 这次来详细的探究一下它们的触发顺序和使用场景</p>\n<!-- more -->\n<p>我的测试是在 chrome 版本 73.0.3683.75（正式版本）（64 位）环境, 其它的浏览器可能有不同, 有时间再补充其它浏览器吧.</p>\n<p>目前来说比较常用的有<code>focus</code>/<code>keydown</code>/<code>input</code>/<code>keyup</code>/<code>compositionstart</code>/<code>compositionupdate</code>/<code>compositionend</code>/<code>change</code> </p>\n<p>点击一个输入框开始输入触发的事件顺序依次是: </p>\n<p><code>focus</code>=&gt;<code>keydown</code>(=&gt;<code>compositionstart</code>=&gt;<code>compositionupdate</code>)=&gt;<code>input</code>(=&gt;<code>compositionend</code>)=&gt;<code>keyup</code></p>\n<p>如果是组合输入(比如中文日文等)输入的话就会出现括号中组合输入事件, 详细来说是当开始输入中文的时候就会触发<code>compositionstart</code>事件, 此时<code>input</code>事件和<code>keyup</code>事件拿到的输入框的值是不完整的(一般包含你输入的拼音和拼音之间的分号), 当中文输入结束的时候会触发<code>compositionend</code>事件, 此时可以取到该输入框的完整的输入中文后的值(一般而言这个值是我们所需要的)</p>\n<p>(额外的一点是从<code>input</code>事件开始可以拿到最新输入的值, 前面的事件拿到的值都要落后一次, 少了最后一次输入的字符)</p>\n<p><code>change</code>事件的触发需要<strong>两个条件</strong>, 一是<code>input</code>元素即将失焦, 事件顺序是<code>change</code>=&gt;<code>blur</code>, 二是本次失焦后的内容与前一次失焦后的内容不同(如果相同是不会触发该事件的),</p>\n<p>最常用的场景之一是<code>input</code>用来搜索的时候, 我们的需求是输入变化的时候就去查询(当然有节流), 但是在中文输入的时候就不要查询, 直到中文输入结束之后再查询, 这样可以避免用一些明显无效的关键词如<code>文章n'r</code>去查询, 等到完整中文输入后变成<code>文章内容</code>再去查询</p>\n<pre><code class=\"language-js\">function throttle(fn, minDelay, maxDelay) {\n  let timer;\n  let startTime = new Date();\n  return function () {\n    const context = this;\n    const args = arguments;\n    let curTime = new Date();\n    clearTimeout(timer);\n    if (curTime - startTime &gt;= maxDelay) {\n      fn.apply(context, args);\n      startTime = curTime;\n    } else {\n      timer = setTimeout(() =&gt; {\n        fn.apply(context, args);\n      }, minDelay);\n    }\n  }\n}\n\nfunction listenInput(selector, cb, delay = 150, maxDelay = 1000) {\n  const el = document.querySelector(selector);\n  if(!el || !cb || typeof cb !== 'function') {\n    return false;\n  }\n  const throttleCB = throttle(cb, delay, maxDelay);\n  let isComposition = false;\n  const compositionstart = () =&gt; isComposition = true;\n  const compositionend = () =&gt; {\n    isComposition = false;\n    throttleCB(el.value);\n  };\n  const input = () =&gt; {\n    if(isComposition) {\n      return false;\n    }\n    throttleCB(el.value);\n  }\n\n  el.addEventListener('compositionstart', compositionstart);\n  el.addEventListener('compositionend', compositionend);\n  el.addEventListener('input', input);\n  \n  return () =&gt; {\n    el.removeEventListener('compositionstart', compositionstart);\n    el.removeEventListener('compositionend', compositionend);\n    el.removeEventListener('input', input);\n  }\n}\n\n// 使用示例\n// 开始监听, 默认最小间隔时间是150ms, 最大间隔时间是1000ms\nconst removeListener = listenInput('#inputId', value =&gt; {\n  console.log(value);\n}, 100, 1500);\n\n// 取消监听\nremoveListener();\n</code></pre>\n","c_time":"2021-11-18 03:05:44","m_time":"2021-11-18 03:05:44"}