{"path":"ts","title":"","summary":"typescript以前的ts笔记不知道去哪了, 心痛, 重新整理写一下吧发现一个写的很详细的ts中文文档:深入理解 TypeScript部分“神奇参数“esModuleInterop: boolea","text":"typescript以前的ts笔记不知道去哪了, 心痛, 重新整理写一下吧发现一个写的很详细的ts中文文档:深入理解 TypeScript部分“神奇参数“esModuleInterop: booleanesModuleInterop 到底做了什么？简单来说是由于CommonJS和ES module对于默认导出导入的逻辑不一致, 所以在使用ts把ES module模块代码编译成CommonJS模块代码时需要进行的一个特殊处理, 这个参数影响的是ts对于import的转译规则(export不受影响)babel 默认的转译规则和 TS 开启 esModuleInterop 的情况差不多, 所以如果旧代码是使用babel打包的, 那么大概率你在切换到ts打包后需要手动开启这个参数对于默认如下导入// 注意 React 的声明文件本身没有默认导出, 都是 exports.Children = Children 这样的导出方式\n// 在js中我们可以直接使用下面的默认导出, 会把所有属性都挂载到这个对象上\n// 但是在ts中没有默认导出的时候, 我们应该使用 import * as React from 'react' 的方法来达到js中同样的效果\n// 这里在ts仍然使用js的导入方法只是为了演示会导致什么样的结果, 以及开启 esModuleInterop 参数后就可以\"修复\"这种行为\nimport React from 'react';\nconsole.log(React);\n\n// 转译后\n// esModuleInterop: fasle (默认值) \n\"use strict\";\nexports.__esModule = true;\nvar react_1 = require(\"react\");\n// 这里实际会打印出 undefined , 因为 React 没有默认导出(default)\nconsole.log(react_1[\"default\"]);\n\n// esModuleInterop: true\n// (代码经过简化, 主要是使用默认导出的地方会包上一层 __importDefault 处理 default 属性的调用)\nvar __importDefault = function (mod) {\n  return mod && mod.__esModule ? mod : { default: mod };\n};\n var react = __importDefault(require('react'));\n// 这里可以正常打印结果, 因为 __importDefault 手动把所有属性挂载到了 default 上达到了babel一样的效果\n console.log(react['default']);\nmoduleResolution: ‘node’ | ‘classic’表示模块解析策略, 如果module配置是 commonjs 那么默认采用 node 解析策略, 如果module是其他值(amd, system, umd, es2015, esnext, etc.), 那么默认采用 classic, 使用 node 解析策略的较多, 因为用webpack 打包的时候是基于node模式, 所以 ts 配置为node更符合我们日常的认知和做法, 采取的两种解析模式的差别如下// 在源文件/root/src/A中导入一个模块, 两种解析方式查找文件方式不同\nimport { b } from \"./moduleB\"\n\n// classic模块解析方式\n1. /root/src/moduleB.ts\n2. /root/src/moduleB.d.ts\n\n// node模块解析方式\n1. /root/src/moduleB.ts\n2. /root/src/moduleB.tsx\n3. /root/src/moduleB.d.ts\n4. /root/src/moduleB/package.json (if it specifies a \"types\" property)\n5. /root/src/moduleB/index.ts\n6. /root/src/moduleB/index.tsx\n7. /root/src/moduleB/index.d.ts\n","html":"<h1>typescript</h1>\n<p>以前的ts笔记不知道去哪了, 心痛, 重新整理写一下吧</p>\n<p>发现一个写的很详细的ts中文文档:<a href=\"https://jkchao.github.io/typescript-book-chinese/\">深入理解 TypeScript</a></p>\n<h2>部分“神奇参数“</h2>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\" checked=\"\"/>\n<p>esModuleInterop: boolean</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/148081795\">esModuleInterop 到底做了什么？</a></p>\n<p>简单来说是由于CommonJS和ES module对于默认导出导入的逻辑不一致, 所以在使用ts把ES module模块代码编译成CommonJS模块代码时需要进行的一个特殊处理, 这个参数影响的是ts对于<code>import</code>的转译规则(<code>export</code>不受影响)</p>\n<p>babel 默认的转译规则和 TS 开启 esModuleInterop 的情况差不多, 所以如果旧代码是使用babel打包的, 那么大概率你在切换到ts打包后需要手动开启这个参数</p>\n<p>对于默认如下导入</p>\n<pre><code class=\"language-typescript\">// 注意 React 的声明文件本身没有默认导出, 都是 exports.Children = Children 这样的导出方式\n// 在js中我们可以直接使用下面的默认导出, 会把所有属性都挂载到这个对象上\n// 但是在ts中没有默认导出的时候, 我们应该使用 import * as React from 'react' 的方法来达到js中同样的效果\n// 这里在ts仍然使用js的导入方法只是为了演示会导致什么样的结果, 以及开启 esModuleInterop 参数后就可以&quot;修复&quot;这种行为\nimport React from 'react';\nconsole.log(React);\n\n// 转译后\n// esModuleInterop: fasle (默认值) \n&quot;use strict&quot;;\nexports.__esModule = true;\nvar react_1 = require(&quot;react&quot;);\n// 这里实际会打印出 undefined , 因为 React 没有默认导出(default)\nconsole.log(react_1[&quot;default&quot;]);\n\n// esModuleInterop: true\n// (代码经过简化, 主要是使用默认导出的地方会包上一层 __importDefault 处理 default 属性的调用)\nvar __importDefault = function (mod) {\n  return mod &amp;&amp; mod.__esModule ? mod : { default: mod };\n};\n var react = __importDefault(require('react'));\n// 这里可以正常打印结果, 因为 __importDefault 手动把所有属性挂载到了 default 上达到了babel一样的效果\n console.log(react['default']);\n</code></pre>\n</li>\n<li><input disabled=\"\" type=\"checkbox\" checked=\"\"/>\n<p>moduleResolution: ‘node’ | ‘classic’</p>\n<p>表示模块解析策略, 如果module配置是 commonjs 那么默认采用 node 解析策略, 如果module是其他值(<code>amd</code>, <code>system</code>, <code>umd</code>, <code>es2015</code>, <code>esnext</code>, etc.), 那么默认采用 classic, 使用 node 解析策略的较多, 因为用webpack 打包的时候是基于node模式, 所以 ts 配置为node更符合我们日常的认知和做法, 采取的两种解析模式的差别如下</p>\n<pre><code>// 在源文件/root/src/A中导入一个模块, 两种解析方式查找文件方式不同\nimport { b } from &quot;./moduleB&quot;\n\n// classic模块解析方式\n1. /root/src/moduleB.ts\n2. /root/src/moduleB.d.ts\n\n// node模块解析方式\n1. /root/src/moduleB.ts\n2. /root/src/moduleB.tsx\n3. /root/src/moduleB.d.ts\n4. /root/src/moduleB/package.json (if it specifies a &quot;types&quot; property)\n5. /root/src/moduleB/index.ts\n6. /root/src/moduleB/index.tsx\n7. /root/src/moduleB/index.d.ts\n</code></pre>\n</li>\n</ul>\n","c_time":"2021-11-18 03:05:44","m_time":"2021-11-18 03:05:44"}