{"path":"rust","title":"","summary":"rustStringvs&Stringvs&strString: 可变的，堆上分配的UTF-8字节缓冲区，有len()和``capaciry*() (注: len()代表当前实际占用的空间, capa","text":"rustStringvs&Stringvs&strString: 可变的，堆上分配的UTF-8字节缓冲区，有len()和``capaciry*() (注: len()代表当前实际占用的空间, capacity()代表已经分配的空间, 可能是大于len()的, 类比一个大小为10的数组当前只存储了一个对象)，例如: let mut a = String::from(“demo”);`&String: 引用String, 由于只是引用, 不获取所有权, 无法修改, 所以可以当做&str(类型也不会报错)&str: 不可变的固定长度的字符串，如果是从String解引用来的则指向堆，如果是字面值，则指向静态内存，只有len(), 例如：let b = \"demo\"; 互相转换String -> &str:  x.as_str()&str ->  String: x.to_string()|x.to_owned()|String::from(x)iter()vsiter_mut()vsinto_iter()iter(): &selfiter_mut(): &mut selfinto_iter(): selflet v = vec!(47);\nfor i in v.iter() {\n\tassert_eq!(i, &47);\n}\n\nlet mut v = vec!(47);\nfor i in v.iter_mut() {\n\t*i = 48;\n\tassert_eq!(i, &48);\n}\n\nlet v = vec!(47);\nfor mut i in v.into_iter() {\n\ti += 1;\n\tassert_eq!(i, 48);\n}\nclone()vsto_owned()\tref: https://stackoverflow.com/questions/22264502/in-rust-what-is-the-difference-between-clone-and-to-ownedclone(): 只能实现&T -> T, 使用的更频繁一些to_owned(): 可以实现更复杂一些的别的类型->T, 使用的相对少一些AsRefvsAsMutref: https://wiki.jikexueyuan.com/project/rust-primer/intoborrow/asref.html二者都是TraitAsRef: 对一个类型为T的对象foo, 如果T实现了AsRef<U>, 那么foo可执行foo.as_ref()操作, 得到一个&U例如: String和&str都实现了AsRef<str>, 所以一下代码都可以运行fn is_hello<T: AsRef<str>>(s: T) {\n\tassert_eq!(\"hello\", s);\n}\n\nlet s = \"hello\";\nis_hello(s);\n\nlet s2 = \"hello\".to_string();\nis_hello(s2);\nAsMut: 是AsRef的可变引用版本, 对应的方法是.as_mut()&&&&&&str.len()这个表达式之所以能调用，是因为rust的自动解引用特性：https://zhuanlan.zhihu.com/p/21615411函数使用引用参数时，参数不会发生move的, 因为引用会自动按位复制给函数使用Cow","html":"<h1>rust</h1>\n<h2><code>String</code>vs<code>&amp;String</code>vs<code>&amp;str</code></h2>\n<ul>\n<li><code>String</code>: 可变的，堆上分配的<code>UTF-8</code>字节缓冲区，有<code>len()</code>和``capaciry*() <code>(注: </code>len()<code>代表当前实际占用的空间, </code>capacity()<code>代表已经分配的空间, 可能是大于</code>len()<code>的, 类比一个大小为10的数组当前只存储了一个对象)，例如: </code>let mut a = String::from(“demo”);`</li>\n<li><code>&amp;String</code>: 引用<code>String</code>, 由于只是引用, 不获取所有权, 无法修改, 所以可以当做<code>&amp;str</code>(类型也不会报错)</li>\n<li><code>&amp;str</code>: 不可变的固定长度的字符串，如果是从<code>String</code>解引用来的则指向堆，如果是字面值，则指向静态内存，只有<code>len()</code>, 例如：<code>let b = &quot;demo&quot;; </code></li>\n</ul>\n<p>互相转换</p>\n<ul>\n<li><code>String</code> -&gt; <code>&amp;str</code>:  <code>x.as_str()</code></li>\n<li><code>&amp;str</code> -&gt;  <code>String</code>: <code>x.to_string()</code>|<code>x.to_owned()</code>|<code>String::from(x)</code></li>\n</ul>\n<h2><code>iter()</code>vs<code>iter_mut()</code>vs<code>into_iter()</code></h2>\n<p><code>iter()</code>: <code>&amp;self</code>\n<code>iter_mut()</code>: <code>&amp;mut self</code>\n<code>into_iter()</code>: <code>self</code></p>\n<pre><code class=\"language-rust\">let v = vec!(47);\nfor i in v.iter() {\n\tassert_eq!(i, &amp;47);\n}\n\nlet mut v = vec!(47);\nfor i in v.iter_mut() {\n\t*i = 48;\n\tassert_eq!(i, &amp;48);\n}\n\nlet v = vec!(47);\nfor mut i in v.into_iter() {\n\ti += 1;\n\tassert_eq!(i, 48);\n}\n</code></pre>\n<h2><code>clone()</code>vs<code>to_owned()\t</code></h2>\n<p>ref: https://stackoverflow.com/questions/22264502/in-rust-what-is-the-difference-between-clone-and-to-owned\n<code>clone()</code>: 只能实现&amp;T -&gt; T, 使用的更频繁一些\n<code>to_owned()</code>: 可以实现更复杂一些的别的类型-&gt;T, 使用的相对少一些</p>\n<h2><code>AsRef</code>vs<code>AsMut</code></h2>\n<p>ref: https://wiki.jikexueyuan.com/project/rust-primer/intoborrow/asref.html\n二者都是<code>Trait</code>\n<code>AsRef</code>: 对一个类型为<code>T</code>的对象<code>foo</code>, 如果<code>T</code>实现了<code>AsRef&lt;U&gt;</code>, 那么<code>foo</code>可执行<code>foo.as_ref()</code>操作, 得到一个<code>&amp;U</code>\n例如: <code>String</code>和<code>&amp;str</code>都实现了<code>AsRef&lt;str&gt;</code>, 所以一下代码都可以运行</p>\n<pre><code class=\"language-rust\">fn is_hello&lt;T: AsRef&lt;str&gt;&gt;(s: T) {\n\tassert_eq!(&quot;hello&quot;, s);\n}\n\nlet s = &quot;hello&quot;;\nis_hello(s);\n\nlet s2 = &quot;hello&quot;.to_string();\nis_hello(s2);\n</code></pre>\n<p><code>AsMut</code>: 是<code>AsRef</code>的可变引用版本, 对应的方法是<code>.as_mut()</code></p>\n<h2><code>&amp;&amp;&amp;&amp;&amp;&amp;str.len()</code></h2>\n<p>这个表达式之所以能调用，是因为<code>rust</code>的自动解引用特性：https://zhuanlan.zhihu.com/p/21615411\n函数使用引用参数时，参数不会发生<code>move</code>的, 因为引用会自动按位复制给函数使用</p>\n<h2><code>Cow</code></h2>\n","c_time":"2021-11-18 03:05:44","m_time":"2021-11-18 03:05:44"}