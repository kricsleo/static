{"path":"daily-q","title":"","summary":"如何仅使用css实现任意比例图片在容器中最大程度居中展示这个要求在图片预览的场景会出现的比较多, 给定一个展示区域, 要求任意比例的图片都能在这里区域里以最大程度(宽或者高至少有一个是容器边对齐的)的","text":"如何仅使用css实现任意比例图片在容器中最大程度居中展示这个要求在图片预览的场景会出现的比较多, 给定一个展示区域, 要求任意比例的图片都能在这里区域里以最大程度(宽或者高至少有一个是容器边对齐的)的居中展示.当图片本身比容器尺寸要大(无论宽超出还是高超出)时通过max-width:100%和max-height:100%来缩小图片是很好实现的但是当图片本身比容器尺寸要小的时候, 如何放大图片到宽或者高对齐容器, 这一点仅依靠css如何实现?附上一个demoabsolute 元素仍然会导致父元素的滚动条出现按照我以前的理解, absolute 元素意味着脱离文档流, 文档排版不会考虑该元素的宽高, 所以无论元素的宽高如何都不会引起父级或者祖先级元素的滚动, 但是实际并非如此, 如果你有一个尺寸很大的absolute 元素, 那么在父级或者祖先级元素overflow为auto的时候你就会看到滚动条出现了, 我找到的一个最接近的回答在这里: [Why does position absolute make page to overflow?附上一个测试的demo. 之所以会出现滚动条是因为有一个回答里面提到的:Section 2.3.1For all media, the term canvas describes “the space where the formatting structure is rendered.” The canvas is infinite for each dimension of the space, but rendering generally occurs within a finite region of the canvas, established by the user agent according to the target medium.Section 9.1User agents for continuous media generally offer users a viewport (a window or other viewing area on the screen) through which users consult a document.When the viewport is smaller than the area of the canvas on which the document is rendered, the user agent should offer a scrolling mechanism.按照CSS 2.1文档中的规范, 当viewport(视口)小于canvas(画布)时浏览器应该提供一种滚动机制来允许用户查看完整内容, 所以对于absolute元素虽然脱离了文档流, 但是仍然是在canvas(画布)上绘制的, 所以当absolute元素宽高溢出的时候会导致滚动条的出现, 这是符合规范的.但是很神奇的一点是当元素是属于向左或者向上溢出的时候并不会导致滚动条, 但是向右或者向下溢出的时候就会导致滚动条, 关于这一点的解释按照回答里的几个说法是与浏览器绘制的“canvas“(画布)有关系, 绘制时按照x:0,y:0的起点开始在画布上绘制所有元素, 当负向超出画布时浏览器认为是不可见的内容, 所以不会出现滚动条, 但是正向超出画布内容时浏览器会认为内容应该是可见的, 就会尝试用滚动的方式来展示这些内容.延伸出的两点是:想要通过absolute定位溢出可见区域的方式来隐藏元素时要使用向上或者向左负值的方式, 如果使用向右或者向下负值的方式则有可能导致祖先级元素出现滚动条(overflow: auto的情况)使用fixed定位不受上面说的规则的限制, 也不会导致上面的现象","html":"<ul>\n<li><input disabled=\"\" type=\"checkbox\"/>\n<p>如何仅使用css实现任意比例图片在容器中最大程度居中展示</p>\n<p>这个要求在图片预览的场景会出现的比较多, 给定一个展示区域, 要求任意比例的图片都能在这里区域里以最大程度(宽或者高至少有一个是容器边对齐的)的居中展示.</p>\n<p>当图片本身比容器尺寸要大(无论宽超出还是高超出)时通过<code>max-width:100%</code>和<code>max-height:100%</code>来缩小图片是很好实现的</p>\n<p>但是当图片本身比容器尺寸要小的时候, 如何放大图片到宽或者高对齐容器, 这一点仅依靠css如何实现?</p>\n<p>附上一个<a href=\"https://codesandbox.io/s/just-using-css-to-solve-this-problem-fk8pi?file=/src/App.vue\">demo</a></p>\n</li>\n<li><input disabled=\"\" type=\"checkbox\" checked=\"\"/>\n<p>absolute 元素仍然会导致父元素的滚动条出现</p>\n<p>按照我以前的理解, absolute 元素意味着脱离文档流, 文档排版不会考虑该元素的宽高, 所以无论元素的宽高如何都不会引起父级或者祖先级元素的滚动, 但是实际并非如此, 如果你有一个尺寸很大的absolute 元素, 那么在父级或者祖先级元素overflow为auto的时候你就会看到滚动条出现了, 我找到的一个最接近的回答在这里: [Why does position absolute make page to overflow?附上一个测试的<a href=\"https://codepen.io/pen?template=KKzJamb\">demo</a>. </p>\n<p>之所以会出现滚动条是因为有一个回答里面提到的:</p>\n<blockquote>\n<p><a href=\"https://www.w3.org/TR/CSS2/intro.html#canvas\">Section 2.3.1</a></p>\n<blockquote>\n<p>For all media, the term canvas describes “the space where the formatting structure is rendered.” The canvas is infinite for each dimension of the space, but rendering generally occurs within a finite region of the canvas, established by the user agent according to the target medium.</p>\n</blockquote>\n<p><a href=\"https://www.w3.org/TR/CSS2/visuren.html#viewport\">Section 9.1</a></p>\n<blockquote>\n<p>User agents for continuous media generally offer users a viewport (a window or other viewing area on the screen) through which users consult a document.</p>\n<p>When the viewport is smaller than the area of the canvas on which the document is rendered, the user agent should offer a scrolling mechanism.</p>\n</blockquote>\n</blockquote>\n<p>按照CSS 2.1文档中的规范, 当viewport(视口)小于canvas(画布)时浏览器应该提供一种滚动机制来允许用户查看完整内容, 所以对于absolute元素虽然脱离了文档流, 但是仍然是在canvas(画布)上绘制的, 所以当absolute元素宽高溢出的时候会导致滚动条的出现, 这是符合规范的.</p>\n<p>但是很神奇的一点是当元素是属于向左或者向上溢出的时候并不会导致滚动条, 但是向右或者向下溢出的时候就会导致滚动条, 关于这一点的解释按照回答里的几个说法是与浏览器绘制的“canvas“(画布)有关系, 绘制时按照x:0,y:0的起点开始在画布上绘制所有元素, 当负向超出画布时浏览器认为是不可见的内容, 所以不会出现滚动条, 但是正向超出画布内容时浏览器会认为内容应该是可见的, 就会尝试用滚动的方式来展示这些内容.</p>\n<p>延伸出的两点是:</p>\n<ol>\n<li>想要通过absolute定位溢出可见区域的方式来隐藏元素时要使用向上或者向左负值的方式, 如果使用向右或者向下负值的方式则有可能导致祖先级元素出现滚动条(overflow: auto的情况)</li>\n<li>使用fixed定位不受上面说的规则的限制, 也不会导致上面的现象</li>\n</ol>\n</li>\n</ul>\n","c_time":"2021-11-18 03:05:44","m_time":"2021-11-18 03:05:44"}