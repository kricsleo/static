{"path":"webp","title":"","summary":"webpwebp 图片格式简介webp格式是由Google开发的一种图片格式, 可支持对带透明度或者无透明度的jpg,png,gif等格式的图片进行有损压缩或者无损压缩, 一般来说, 有损压缩可减少2","text":"webpwebp 图片格式简介webp格式是由Google开发的一种图片格式, 可支持对带透明度或者无透明度的jpg,png,gif等格式的图片进行有损压缩或者无损压缩, 一般来说, 有损压缩可减少25%~34%的体积, 无损压缩可以减少26%左右的体积, 由于需要额外的编解码过程, 所以相比于jpg图片来说编码速度慢10倍, 解码速度慢1.5倍, 但是由于减少了体积, 也就减少了网络传输时间, 总体来说的图片加载完成的时间是要明显短的, 推荐在浏览器支持的情况下使用webp格式图片来代替其他格式(压缩体积视源文件不同而有所浮动, 解码效率也视运行平台有所浮动, 上面数据是测试的平均值)端支持情况及判断是否支持的方式浏览器支持情况: 同步方式: 根据上图的数据来看, 在主流浏览器中现在(2020.12.29)可以认为Edge, Firefox和Chrome的浏览器可以放心使用webp, 通过检查userAgent可以直接判断const userAgentStr = window.navigator.userAgent.toLowerCase();\nconst isSafeBrowserToUseWebp = ['chrome', 'firefox', 'edege'].some(t => userAgentStr.includes(t));\n异步方式: 使用图片检测实际支持情况, 我们尝试加载一张很小的base64格式的webp图片, 如果加载失败(onerror)了则可以认为是不支持webp// 带透明度的base64格式的webp图片数据\nconst webpBase64 = 'data:image/webp;base64,UklGRiYAAABXRUJQVlA4IBoAAAAwAQCdASoBAAEAAAAMJaQAA3AA/v89WAAAAA==';\nconst image = new Image();\nlet canUseWebp;\nimage.onload = () => {\n  // 加载成功以后保险起见进一步判断一下图片高度是否大于0\n  canUseWebp = image.height > 0;\n}\nimage.onerror = () => {\n  canUseWebp = false;\n}\n浏览器头:浏览器如果支持webp,那么会在Accept请求头中附带image/webp, 服务器就可以知道当前的客户端是支持webp的微信小程序: 一直也有在做小程序的开发, 所以小程序这块的webp支持程度也是需要了解的微信小程序在ios和android还有开发者工具上采用的是不同的底层框架, 对webp的支持程度也由其底层实现来决定PC和Mac: 这两个平台的微信小程序均不支持webpandroid: android平台的微信使用的腾讯x5内核, 一直都支持webpios: ios系统本身是不支持webp(就好像safari也不支持webp一样), 官方文档宣称在小程序基础库升级到2.9.0及以上之后可以在ios上支持webp, 但是经过我测试发现, 腾讯出品的文档一如既往的垃圾, 测试结果表明是否支持webpp同时受到ios版本和微信基础库版本两者的限制, 表现如下:ios系统处于14.x(我测试的是14.2)即使小程序基础库低于2.9.0(我测试的是2.6.0)可以在<Image />和background-image中直接支持webp如果ios低于14.x(比如我同事的11.4.1)即使基础升级到了2.9.0也还是不支持webp, 一直升级基础库测试直到2.10.1才在<Image />组件中支持了webp的显示, 注意<Image />要开启webp参数, 对于background-image还是不支持利用手边的资源进行实际测试,本次测试微信基础库版本以2.10.1为准, 只要2.10.1支持webp, 则认为更高版本的基础库也支持webp,微信本身的版本默认对测试结果无影响ios系统以11.4.1, 12.2, 13.4.1, 14.0, 14.2(我借到的五款ios系统)为准,能够显示webp图片则认为支持webp, 同时测试了<Image />和background-image的支持程度, 测试结果如下:可以看到从ios11.4.1(也许更早的系统也支持,但是我手上没有样机资源)和小程序基础库2.10.1开始支持了在<Image />组件中开启webp参数以后使用webp图片对于background-image的方式可以认为从14.0开始就支持, 即使小程序库低于2.10.1(因为我的项目库设置的是2.6.0, 所以低于2.6.0的库不再进行测试)针对以上的测试结果可以小程序中加入如下是否可以使用webp的代码判断/**\n * 比较源版本号和目标版本号的高低\n * -1: 源版本低, 0: 源版本与目标版本相同, 1: 源版本高\n * @param v1 源版本号\n * @param v2 目标版本号\n */\nfunction compareVersion(v1: string, v2:string): -1 | 0 | 1 {\n  const v1Arr = v1.split('.')\n  const v2Arr = v2.split('.')\n  const len = Math.max(v1Arr.length, v2Arr.length)\n\n  while (v1Arr.length < len) {\n    v1Arr.push('0')\n  }\n  while (v2Arr.length < len) {\n    v2Arr.push('0')\n  }\n\n  for (let i = 0; i < len; i++) {\n    const num1 = parseInt(v1Arr[i])\n    const num2 = parseInt(v2Arr[i])\n\n    if (num1 > num2) {\n      return 1\n    } else if (num1 < num2) {\n      return -1\n    }\n  }\n\n  return 0;\n}\n\n// ios环境 webp 支持情况\nconst supportedWebpVerison = {\n  // <Image />支持 webp 的最低版本\n  wechatLib: '2.10.1',\n  // ios支持 <Image /> 方式使用 webp 的最低版本\n  ios: '11.4.1',\n  // ios支持 backgroundImage 方式使用 webp 的最低版本\n  iosBackgroundImage: '14.0',\n}\n\n/**\n * 是否可使用webp格式图片\n * [image 组件是否支持webp, backgroundImage 是否支持webp]\n */\nexport function checkWebp(): [boolean, boolean] {\n  const { platform, system, SDKVersion } = getSystemInfoSync() || {};\n  if (platform === 'android') {\n    return [true, true];\n  } else if(platform === 'ios') {\n    const systemVersion = system.split(' ')[1];\n    const isSupportBackgroundImage = compareVersion(systemVersion, supportedWebpVerison.iosBackgroundImage) >= 0;\n    const isSupportImage = compareVersion(systemVersion, supportedWebpVerison.ios) >= 0 && compareVersion(SDKVersion, supportedWebpVerison.wechatLib) >= 0;\n    return [isSupportImage, isSupportBackgroundImage];\n  }\n  return [false, false];\n}\n20200107补充h5中<Img />是没有子元素的, 但是小程序中<Image />发现可以支持子元素, 这一点并未在官方文档和相关社区描述中提到, 但是偶然的测试发现是支持的,可能是由于小程序的独立渲染机制所导致的,猜测<Image />实际渲染时也是先生成一个视口来占位,然后再将一个图片元素填充到这个视口中, 看起来就好像是一个单独的图片一样, 所以实际测试可以在<Image />里面放入View,Text, Image等元素, 默认图片会填满这个视口, 但是如果里面的子元素太大了宽高溢出的话也可以设置overflow: auto来滚动,你可以把<Image />也类比为一个<View />来理解, 这一点在再加上<Image />对webp的支持程度好一些, 是可以好好利用的","html":"<h1>webp</h1>\n<h2>webp 图片格式简介</h2>\n<p>webp格式是由Google开发的一种图片格式, 可支持对带透明度或者无透明度的jpg,png,gif等格式的图片进行有损压缩或者无损压缩, 一般来说, 有损压缩可减少25%~34%的体积, 无损压缩可以减少26%左右的体积, 由于需要额外的编解码过程, 所以相比于jpg图片来说编码速度慢10倍, 解码速度慢1.5倍, 但是由于减少了体积, 也就减少了网络传输时间, 总体来说的图片加载完成的时间是要明显短的, 推荐在浏览器支持的情况下使用webp格式图片来代替其他格式</p>\n<p>(压缩体积视源文件不同而有所浮动, 解码效率也视运行平台有所浮动, 上面数据是测试的平均值)</p>\n<h2>端支持情况及判断是否支持的方式</h2>\n<p>浏览器支持情况: </p>\n<img src=\"https://kricsleo.oss-cn-hangzhou.aliyuncs.com/images/image-20201229122158778.png\" width=\"1000px\" />\n<ul>\n<li>同步方式: 根据上图的数据来看, 在主流浏览器中现在(2020.12.29)可以认为Edge, Firefox和Chrome的浏览器可以放心使用webp, 通过检查userAgent可以直接判断</li>\n</ul>\n<pre><code class=\"language-javascript\">const userAgentStr = window.navigator.userAgent.toLowerCase();\nconst isSafeBrowserToUseWebp = ['chrome', 'firefox', 'edege'].some(t =&gt; userAgentStr.includes(t));\n</code></pre>\n<ul>\n<li>异步方式: 使用图片检测实际支持情况, 我们尝试加载一张很小的base64格式的webp图片, 如果加载失败(onerror)了则可以认为是不支持webp</li>\n</ul>\n<pre><code class=\"language-javascript\">// 带透明度的base64格式的webp图片数据\nconst webpBase64 = 'data:image/webp;base64,UklGRiYAAABXRUJQVlA4IBoAAAAwAQCdASoBAAEAAAAMJaQAA3AA/v89WAAAAA==';\nconst image = new Image();\nlet canUseWebp;\nimage.onload = () =&gt; {\n  // 加载成功以后保险起见进一步判断一下图片高度是否大于0\n  canUseWebp = image.height &gt; 0;\n}\nimage.onerror = () =&gt; {\n  canUseWebp = false;\n}\n</code></pre>\n<ul>\n<li>\n<p>浏览器头:浏览器如果支持webp,那么会在Accept请求头中附带image/webp, 服务器就可以知道当前的客户端是支持webp的</p>\n</li>\n<li>\n<p>微信小程序: 一直也有在做小程序的开发, 所以小程序这块的webp支持程度也是需要了解的</p>\n<p>微信小程序在ios和android还有开发者工具上采用的是不同的底层框架, 对webp的支持程度也由其底层实现来决定</p>\n<ul>\n<li>\n<p>PC和Mac: 这两个平台的微信小程序均不支持webp</p>\n</li>\n<li>\n<p>android: android平台的微信使用的腾讯x5内核, 一直都支持webp</p>\n</li>\n<li>\n<p>ios: ios系统本身是不支持webp(就好像safari也不支持webp一样), <a href=\"https://developers.weixin.qq.com/community/develop/issue/130\">官方文档</a>宣称在小程序基础库升级到<code>2.9.0</code>及以上之后可以在ios上支持webp, 但是经过我测试发现, <strong>腾讯出品的文档一如既往的垃圾</strong>, 测试结果表明是否支持webpp同时受到ios版本和微信基础库版本两者的限制, 表现如下:</p>\n<ul>\n<li>\n<p>ios系统处于14.x(我测试的是14.2)即使小程序基础库低于<code>2.9.0</code>(我测试的是2.6.0)可以在<code>&lt;Image /&gt;</code>和<code>background-image</code>中直接支持webp</p>\n</li>\n<li>\n<p>如果ios低于14.x(比如我同事的11.4.1)即使基础升级到了<code>2.9.0</code>也还是不支持webp, 一直升级基础库测试直到<code>2.10.1</code>才在<code>&lt;Image /&gt;</code>组件中支持了webp的显示, 注意<code>&lt;Image /&gt;</code>要开启webp参数, 对于<code>background-image</code>还是不支持</p>\n</li>\n<li>\n<p>利用手边的资源进行实际测试,本次测试微信基础库版本以<code>2.10.1</code>为准, 只要<code>2.10.1</code>支持webp, 则认为更高版本的基础库也支持webp,微信本身的版本默认对测试结果无影响</p>\n<p>ios系统以11.4.1, 12.2, 13.4.1, 14.0, 14.2(我借到的五款ios系统)为准,能够显示webp图片则认为支持webp, 同时测试了<code>&lt;Image /&gt;</code>和<code>background-image</code>的支持程度, 测试结果如下:</p>\n<img src=\"https://kricsleo.oss-cn-hangzhou.aliyuncs.com/images/image-20201230201809379.png\" width=\"1000px\" />\n<p>可以看到从ios11.4.1(也许更早的系统也支持,但是我手上没有样机资源)和小程序基础库<code>2.10.1</code>开始支持了在<code>&lt;Image /&gt;</code>组件中开启webp参数以后使用webp图片</p>\n<p>对于<code>background-image</code>的方式可以认为从14.0开始就支持, 即使小程序库低于<code>2.10.1</code>(因为我的项目库设置的是2.6.0, 所以低于2.6.0的库不再进行测试)</p>\n<p>针对以上的测试结果可以小程序中加入如下是否可以使用webp的代码判断</p>\n<pre><code class=\"language-typescript\">/**\n * 比较源版本号和目标版本号的高低\n * -1: 源版本低, 0: 源版本与目标版本相同, 1: 源版本高\n * @param v1 源版本号\n * @param v2 目标版本号\n */\nfunction compareVersion(v1: string, v2:string): -1 | 0 | 1 {\n  const v1Arr = v1.split('.')\n  const v2Arr = v2.split('.')\n  const len = Math.max(v1Arr.length, v2Arr.length)\n\n  while (v1Arr.length &lt; len) {\n    v1Arr.push('0')\n  }\n  while (v2Arr.length &lt; len) {\n    v2Arr.push('0')\n  }\n\n  for (let i = 0; i &lt; len; i++) {\n    const num1 = parseInt(v1Arr[i])\n    const num2 = parseInt(v2Arr[i])\n\n    if (num1 &gt; num2) {\n      return 1\n    } else if (num1 &lt; num2) {\n      return -1\n    }\n  }\n\n  return 0;\n}\n\n// ios环境 webp 支持情况\nconst supportedWebpVerison = {\n  // &lt;Image /&gt;支持 webp 的最低版本\n  wechatLib: '2.10.1',\n  // ios支持 &lt;Image /&gt; 方式使用 webp 的最低版本\n  ios: '11.4.1',\n  // ios支持 backgroundImage 方式使用 webp 的最低版本\n  iosBackgroundImage: '14.0',\n}\n\n/**\n * 是否可使用webp格式图片\n * [image 组件是否支持webp, backgroundImage 是否支持webp]\n */\nexport function checkWebp(): [boolean, boolean] {\n  const { platform, system, SDKVersion } = getSystemInfoSync() || {};\n  if (platform === 'android') {\n    return [true, true];\n  } else if(platform === 'ios') {\n    const systemVersion = system.split(' ')[1];\n    const isSupportBackgroundImage = compareVersion(systemVersion, supportedWebpVerison.iosBackgroundImage) &gt;= 0;\n    const isSupportImage = compareVersion(systemVersion, supportedWebpVerison.ios) &gt;= 0 &amp;&amp; compareVersion(SDKVersion, supportedWebpVerison.wechatLib) &gt;= 0;\n    return [isSupportImage, isSupportBackgroundImage];\n  }\n  return [false, false];\n}\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>20200107补充</h2>\n<p>h5中<code>&lt;Img /&gt;</code>是没有子元素的, 但是小程序中<code>&lt;Image /&gt;</code>发现可以支持子元素, 这一点并未在官方文档和相关社区描述中提到, 但是偶然的测试发现是支持的,可能是由于小程序的独立渲染机制所导致的,猜测<code>&lt;Image /&gt;</code>实际渲染时也是先生成一个视口来占位,然后再将一个图片元素填充到这个视口中, 看起来就好像是一个单独的图片一样, 所以实际测试可以在<code>&lt;Image /&gt;</code>里面放入<code>View</code>,<code>Text</code>, <code>Image</code>等元素, 默认图片会填满这个视口, 但是如果里面的子元素太大了宽高溢出的话也可以设置<code>overflow: auto</code>来滚动,你可以把<code>&lt;Image /&gt;</code>也类比为一个<code>&lt;View /&gt;</code>来理解, 这一点在再加上<code>&lt;Image /&gt;</code>对webp的支持程度好一些, 是可以好好利用的</p>\n","c_time":"2021-11-18 03:05:44","m_time":"2021-11-18 03:05:44"}