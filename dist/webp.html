<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title></title>
  <link rel="stylesheet" href="https://oss.kricsleo.com/github.min.css" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="article">
    <div class="sidebar">
      <img src="https://oss.kricsleo.com/avatar.jpg" class="sidebar__avatar">
      <input class="sidebar__input" id="sidebar__input" type="text" placeholder="type something" autofocus>
      <ul class="sidebar__input-result" id="sidebar__input-result"></ul>
      <p class="sidebar__copyright">
        @<a href="/">kricleo.com</a>
      </p>
    </div>
    <div class="article__wrapper">
      <div class="article__viewport">
        <div class="article__content">
          <h1>webp</h1>
<h2>webp 图片格式简介</h2>
<p>webp格式是由Google开发的一种图片格式, 可支持对带透明度或者无透明度的jpg,png,gif等格式的图片进行有损压缩或者无损压缩, 一般来说, 有损压缩可减少25%~34%的体积, 无损压缩可以减少26%左右的体积, 由于需要额外的编解码过程, 所以相比于jpg图片来说编码速度慢10倍, 解码速度慢1.5倍, 但是由于减少了体积, 也就减少了网络传输时间, 总体来说的图片加载完成的时间是要明显短的, 推荐在浏览器支持的情况下使用webp格式图片来代替其他格式</p>
<p>(压缩体积视源文件不同而有所浮动, 解码效率也视运行平台有所浮动, 上面数据是测试的平均值)</p>
<h2>端支持情况及判断是否支持的方式</h2>
<p>浏览器支持情况: </p>
<img src="https://kricsleo.oss-cn-hangzhou.aliyuncs.com/images/image-20201229122158778.png" width="1000px" />
<ul>
<li>同步方式: 根据上图的数据来看, 在主流浏览器中现在(2020.12.29)可以认为Edge, Firefox和Chrome的浏览器可以放心使用webp, 通过检查userAgent可以直接判断</li>
</ul>
<pre><code class="language-javascript">const userAgentStr = window.navigator.userAgent.toLowerCase();
const isSafeBrowserToUseWebp = ['chrome', 'firefox', 'edege'].some(t =&gt; userAgentStr.includes(t));
</code></pre>
<ul>
<li>异步方式: 使用图片检测实际支持情况, 我们尝试加载一张很小的base64格式的webp图片, 如果加载失败(onerror)了则可以认为是不支持webp</li>
</ul>
<pre><code class="language-javascript">// 带透明度的base64格式的webp图片数据
const webpBase64 = 'data:image/webp;base64,UklGRiYAAABXRUJQVlA4IBoAAAAwAQCdASoBAAEAAAAMJaQAA3AA/v89WAAAAA==';
const image = new Image();
let canUseWebp;
image.onload = () =&gt; {
  // 加载成功以后保险起见进一步判断一下图片高度是否大于0
  canUseWebp = image.height &gt; 0;
}
image.onerror = () =&gt; {
  canUseWebp = false;
}
</code></pre>
<ul>
<li>
<p>浏览器头:浏览器如果支持webp,那么会在Accept请求头中附带image/webp, 服务器就可以知道当前的客户端是支持webp的</p>
</li>
<li>
<p>微信小程序: 一直也有在做小程序的开发, 所以小程序这块的webp支持程度也是需要了解的</p>
<p>微信小程序在ios和android还有开发者工具上采用的是不同的底层框架, 对webp的支持程度也由其底层实现来决定</p>
<ul>
<li>
<p>PC和Mac: 这两个平台的微信小程序均不支持webp</p>
</li>
<li>
<p>android: android平台的微信使用的腾讯x5内核, 一直都支持webp</p>
</li>
<li>
<p>ios: ios系统本身是不支持webp(就好像safari也不支持webp一样), <a href="https://developers.weixin.qq.com/community/develop/issue/130">官方文档</a>宣称在小程序基础库升级到<code>2.9.0</code>及以上之后可以在ios上支持webp, 但是经过我测试发现, <strong>腾讯出品的文档一如既往的垃圾</strong>, 测试结果表明是否支持webpp同时受到ios版本和微信基础库版本两者的限制, 表现如下:</p>
<ul>
<li>
<p>ios系统处于14.x(我测试的是14.2)即使小程序基础库低于<code>2.9.0</code>(我测试的是2.6.0)可以在<code>&lt;Image /&gt;</code>和<code>background-image</code>中直接支持webp</p>
</li>
<li>
<p>如果ios低于14.x(比如我同事的11.4.1)即使基础升级到了<code>2.9.0</code>也还是不支持webp, 一直升级基础库测试直到<code>2.10.1</code>才在<code>&lt;Image /&gt;</code>组件中支持了webp的显示, 注意<code>&lt;Image /&gt;</code>要开启webp参数, 对于<code>background-image</code>还是不支持</p>
</li>
<li>
<p>利用手边的资源进行实际测试,本次测试微信基础库版本以<code>2.10.1</code>为准, 只要<code>2.10.1</code>支持webp, 则认为更高版本的基础库也支持webp,微信本身的版本默认对测试结果无影响</p>
<p>ios系统以11.4.1, 12.2, 13.4.1, 14.0, 14.2(我借到的五款ios系统)为准,能够显示webp图片则认为支持webp, 同时测试了<code>&lt;Image /&gt;</code>和<code>background-image</code>的支持程度, 测试结果如下:</p>
<img src="https://kricsleo.oss-cn-hangzhou.aliyuncs.com/images/image-20201230201809379.png" width="1000px" />
<p>可以看到从ios11.4.1(也许更早的系统也支持,但是我手上没有样机资源)和小程序基础库<code>2.10.1</code>开始支持了在<code>&lt;Image /&gt;</code>组件中开启webp参数以后使用webp图片</p>
<p>对于<code>background-image</code>的方式可以认为从14.0开始就支持, 即使小程序库低于<code>2.10.1</code>(因为我的项目库设置的是2.6.0, 所以低于2.6.0的库不再进行测试)</p>
<p>针对以上的测试结果可以小程序中加入如下是否可以使用webp的代码判断</p>
<pre><code class="language-typescript">/**
 * 比较源版本号和目标版本号的高低
 * -1: 源版本低, 0: 源版本与目标版本相同, 1: 源版本高
 * @param v1 源版本号
 * @param v2 目标版本号
 */
function compareVersion(v1: string, v2:string): -1 | 0 | 1 {
  const v1Arr = v1.split('.')
  const v2Arr = v2.split('.')
  const len = Math.max(v1Arr.length, v2Arr.length)

  while (v1Arr.length &lt; len) {
    v1Arr.push('0')
  }
  while (v2Arr.length &lt; len) {
    v2Arr.push('0')
  }

  for (let i = 0; i &lt; len; i++) {
    const num1 = parseInt(v1Arr[i])
    const num2 = parseInt(v2Arr[i])

    if (num1 &gt; num2) {
      return 1
    } else if (num1 &lt; num2) {
      return -1
    }
  }

  return 0;
}

// ios环境 webp 支持情况
const supportedWebpVerison = {
  // &lt;Image /&gt;支持 webp 的最低版本
  wechatLib: '2.10.1',
  // ios支持 &lt;Image /&gt; 方式使用 webp 的最低版本
  ios: '11.4.1',
  // ios支持 backgroundImage 方式使用 webp 的最低版本
  iosBackgroundImage: '14.0',
}

/**
 * 是否可使用webp格式图片
 * [image 组件是否支持webp, backgroundImage 是否支持webp]
 */
export function checkWebp(): [boolean, boolean] {
  const { platform, system, SDKVersion } = getSystemInfoSync() || {};
  if (platform === 'android') {
    return [true, true];
  } else if(platform === 'ios') {
    const systemVersion = system.split(' ')[1];
    const isSupportBackgroundImage = compareVersion(systemVersion, supportedWebpVerison.iosBackgroundImage) &gt;= 0;
    const isSupportImage = compareVersion(systemVersion, supportedWebpVerison.ios) &gt;= 0 &amp;&amp; compareVersion(SDKVersion, supportedWebpVerison.wechatLib) &gt;= 0;
    return [isSupportImage, isSupportBackgroundImage];
  }
  return [false, false];
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>20200107补充</h2>
<p>h5中<code>&lt;Img /&gt;</code>是没有子元素的, 但是小程序中<code>&lt;Image /&gt;</code>发现可以支持子元素, 这一点并未在官方文档和相关社区描述中提到, 但是偶然的测试发现是支持的,可能是由于小程序的独立渲染机制所导致的,猜测<code>&lt;Image /&gt;</code>实际渲染时也是先生成一个视口来占位,然后再将一个图片元素填充到这个视口中, 看起来就好像是一个单独的图片一样, 所以实际测试可以在<code>&lt;Image /&gt;</code>里面放入<code>View</code>,<code>Text</code>, <code>Image</code>等元素, 默认图片会填满这个视口, 但是如果里面的子元素太大了宽高溢出的话也可以设置<code>overflow: auto</code>来滚动,你可以把<code>&lt;Image /&gt;</code>也类比为一个<code>&lt;View /&gt;</code>来理解, 这一点在再加上<code>&lt;Image /&gt;</code>对webp的支持程度好一些, 是可以好好利用的</p>

        </div>
      </div>
    </div>
  </div>
  <script src="https://oss.kricsleo.com/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <script src="index.js"></script>
</body>
</html>