{"path":"Airbnb-JavaScript-Style-Guide","title":"Airbnb-JavaScript-Style-Guide","summary":"Airbnb JavaScript Style Guide 阅读笔记Airbnb的JavaScript代码风格是世界上最流行的JavaScript代码风格之一, 在阅读的时候结合我自己的使用经验记录如","text":"Airbnb JavaScript Style Guide 阅读笔记Airbnb的JavaScript代码风格是世界上最流行的JavaScript代码风格之一, 在阅读的时候结合我自己的使用经验记录如下重点, 日后多次阅读应该会持续更新.在线阅读地址: https://github.com/airbnb/javascript(中文翻译版: https://github.com/yuche/javascript)对象使用字面值创建对象// bad\nconst item = new Object();\n\n// good\nconst item = {};\n使用对象方法的简写// bad\nconst atom = {\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  value: 1,\n\n  addValue(value) {\n    return atom.value + value;\n  },\n};\n数组使用字面值创建数组// bad\nconst items = new Array();\n\n// good\nconst items = [];\n使用扩展运算符...复制数组// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n使用Array#from把类数组对象转为数组const foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n解构使用解构存取和使用多属性对象// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n\n  return `${firstName} ${lastName}`;\n}\n\n// good\nfunction getFullName(obj) {\n  const { firstName, lastName } = obj;\n  return `${firstName} ${lastName}`;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n  return `${firstName} ${lastName}`;\n}\n对数组使用解构赋值const arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n回传对个对象时, 使用对象解构, 而不是数组解构为什么？增加属性或者改变排序不会改变调用时的位置。// bad\nfunction processInput(input) {\n  // then a miracle occurs\n  return [left, right, top, bottom];\n}\n\n// 调用时需要考虑回调数据的顺序。\nconst [left, __, top] = processInput(input);\n\n// good\nfunction processInput(input) {\n  // then a miracle occurs\n  return { left, right, top, bottom };\n}\n\n// 调用时只选择需要的数据\nconst { left, right } = processInput(input);\n字符串程序化生成字符串时使用模板字符串代替字符串连接模板字符串更简洁, 根据可读性// bad\nfunction sayHi(name) {\n  return 'How are you, ' + name + '?';\n}\n\n// bad\nfunction sayHi(name) {\n  return ['How are you, ', name, '?'].join();\n}\n\n// good\nfunction sayHi(name) {\n  return `How are you, ${name}?`;\n函数使用函数声明代替函数表达式因为函数声明是可命名的, 所以他们在调用栈中更容易\b被识别. 此外函数声明会把整个函数提升(hoisted), 而函数表达式只会把函数的引用变量名提升. 这条规则是的箭头函数可以取代函数表达式.// bad\nconst foo = function () {\n};\n\n// good\nfunction foo() {\n}\n函数表达式// 立即调用的函数表达式(IIFE)\n(() => {\n    console.log('welcome!')\n})()\n不要使用arguments。可以选择rest语法...替代// bad\nfunction concatenateAll() {\n  const args = Array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}\n直接给函数的参数指定默认值，不要使用一个变化的函数参数。// really bad\nfunction handleThings(opts) {\n  // 不！我们不应该改变函数参数。\n  // 更加糟糕: 如果参数 opts 是 false 的话，它就会被设定为一个对象。\n  // 但这样的写法会造成一些 Bugs。\n  //（译注：例如当 opts 被赋值为空字符串，opts 仍然会被下一行代码设定为一个空对象。）\n  opts = opts || {};\n  // ...\n}\n\n// still bad\nfunction handleThings(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // ...\n}\n\n// good\nfunction handleThings(opts = {}) {\n  // ...\n}\n构造器总是使用class, 避免使用prototype因为class语法更易读// bad\nfunction Queen(contents = []) {\n    this._quene = [...contents];\n}\nQuene.prototype.pop = function() {\n    const value = this._quene[0];\n    this._quene.splice(0, 1);\n    return value;\n}\n\n// good\nclass Queen {\n    constructor(contents = []) {\n        this._quene = [...contents];\n    }\n    pop() {\n        const value = this._quene[0];\n        this._quene.splice(0, 1);\n        return value;\n    }\n}\nIterators and Generators不要使用iterators, 使用高阶函数如map或者reduce来代替for-ofconst numbers = [1, 2, 3, 4, 5];\n\n// bad\nlet sum = 0;\nfor (let num of numbers) {\n  sum += num;\n}\n\nsum === 15;\n\n// good\nlet sum = 0;\nnumbers.forEach((num) => sum += num);\nsum === 15\n\n// best (use the functional force)\nconst sum = numbers.reduce((total, num) => total += num, 0)\nsum === 15\n比较运算符和等号条件表达式例如 if 语句通过抽象方法ToBoolean强制计算它们的表达式并且总是遵守下面的规则：对象 被计算为 trueUndefined 被计算为 falseNull 被计算为 false布尔值 被计算为 布尔的值数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true注释给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME – need to figure this out 或者 TODO – need to implement。class Calculator {\n  constructor() {\n    // FIXME: shouldn't use a global here\n    total = 0;\n  }\n}\n\nclass Calculator {\n  constructor() {\n    // TODO: total should be configurable by an options param\n    this.total = 0;\n  }\n}\n空白使用2个空格作为缩进。在文件末尾插入一个空行。逗号增加结尾的逗号: 需要。JavaScript支持这种做法,并且会自动处理结尾多余的逗号, 好处是会让git diff更干净, 新增字段更方便.另外，像 babel 这样的转译器会移除结尾多余的逗号，也就是说你不必担心老旧浏览器的尾逗号问题。// bad - git diff without trailing comma\nconst hero = {\n     firstName: 'Florence',\n-    lastName: 'Nightingale'\n+    lastName: 'Nightingale',\n+    inventorOf: ['coxcomb graph', 'modern nursing']\n}\n\n// good - git diff with trailing comma\nconst hero = {\n     firstName: 'Florence',\n     lastName: 'Nightingale',\n+    inventorOf: ['coxcomb chart', 'modern nursing'],\n}\n\n// bad\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully'\n};\n\nconst heroes = [\n  'Batman',\n  'Superman'\n];\n\n// good\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully',\n};\n\nconst heroes = [\n  'Batman',\n  'Superman',\n];\n类型转换字符串//  => this.reviewScore = 9;\n\n// bad\nconst totalScore = this.reviewScore + '';\n\n// good\nconst totalScore = String(this.reviewScore);\n如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。// good\n/**\n * 使用 parseInt 导致我的程序变慢，\n * 改成使用位操作转换数字快多了。\n */\nconst val = inputValue >> 0;\n命名规则别保存this的引用。使用箭头函数或Function#bind。// bad\nfunction foo() {\n  const self = this;\n  return function() {\n    console.log(self);\n  };\n}\n\n// bad\nfunction foo() {\n  const that = this;\n  return function() {\n    console.log(that);\n  };\n}\n\n// good\nfunction foo() {\n  return () => {\n    console.log(this);\n  };\n}\n如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。// file contents\nclass CheckBox {\n  // ...\n}\nexport default CheckBox;\n\n// in some other file\n// bad\nimport CheckBox from './checkBox';\n\n// bad\nimport CheckBox from './check_box';\n\n// good\nimport CheckBox from './CheckBox';\n当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。function makeStyleGuide() {\n}\n\nexport default makeStyleGuide;\n当你导出单例、函数库、空对象时使用帕斯卡式命名。const AirbnbStyleGuide = {\n  es6: {\n  }\n};\n\nexport default AirbnbStyleGuide;\n事件当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。// bad\n$(this).trigger('listingUpdated', listing.id);\n\n...\n\n$(this).on('listingUpdated', function(e, listingId) {\n  // do something with listingId\n});\n\n// good\n$(this).trigger('listingUpdated', { listingId : listing.id });\n\n...\n\n$(this).on('listingUpdated', function(e, data) {\n  // do something with data.listingId\n});\n","html":"<h1>Airbnb JavaScript Style Guide 阅读笔记</h1>\n<p>Airbnb的JavaScript代码风格是世界上最流行的JavaScript代码风格之一, 在阅读的时候结合我自己的使用经验记录如下重点, 日后多次阅读应该会持续更新.\n在线阅读地址: https://github.com/airbnb/javascript\n(中文翻译版: https://github.com/yuche/javascript)</p>\n<!-- more -->\n<h2>对象</h2>\n<ol>\n<li>使用字面值创建对象</li>\n</ol>\n<pre><code class=\"language-javascript\">// bad\nconst item = new Object();\n\n// good\nconst item = {};\n</code></pre>\n<ol start=\"2\">\n<li>使用对象方法的简写</li>\n</ol>\n<pre><code class=\"language-javascript\">// bad\nconst atom = {\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  value: 1,\n\n  addValue(value) {\n    return atom.value + value;\n  },\n};\n</code></pre>\n<h2>数组</h2>\n<ol>\n<li>使用字面值创建数组</li>\n</ol>\n<pre><code class=\"language-javascript\">// bad\nconst items = new Array();\n\n// good\nconst items = [];\n</code></pre>\n<ol start=\"2\">\n<li>使用扩展运算符<code>...</code>复制数组</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i &lt; len; i++) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n</code></pre>\n<ol start=\"3\">\n<li>使用Array#from把类数组对象转为数组</li>\n</ol>\n<pre><code class=\"language-JavaScript\">const foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n</code></pre>\n<h2>解构</h2>\n<ol>\n<li>使用解构存取和使用多属性对象</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n\n  return `${firstName} ${lastName}`;\n}\n\n// good\nfunction getFullName(obj) {\n  const { firstName, lastName } = obj;\n  return `${firstName} ${lastName}`;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n  return `${firstName} ${lastName}`;\n}\n</code></pre>\n<ol start=\"2\">\n<li>对数组使用解构赋值</li>\n</ol>\n<pre><code class=\"language-JavaScript\">const arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n</code></pre>\n<ol start=\"3\">\n<li>回传对个对象时, 使用对象解构, 而不是数组解构</li>\n</ol>\n<blockquote>\n<p>为什么？增加属性或者改变排序不会改变调用时的位置。</p>\n</blockquote>\n<pre><code class=\"language-JavaScript\">// bad\nfunction processInput(input) {\n  // then a miracle occurs\n  return [left, right, top, bottom];\n}\n\n// 调用时需要考虑回调数据的顺序。\nconst [left, __, top] = processInput(input);\n\n// good\nfunction processInput(input) {\n  // then a miracle occurs\n  return { left, right, top, bottom };\n}\n\n// 调用时只选择需要的数据\nconst { left, right } = processInput(input);\n</code></pre>\n<h2>字符串</h2>\n<ol>\n<li>程序化生成字符串时使用模板字符串代替字符串连接</li>\n</ol>\n<blockquote>\n<p>模板字符串更简洁, 根据可读性</p>\n</blockquote>\n<pre><code class=\"language-JavaScript\">// bad\nfunction sayHi(name) {\n  return 'How are you, ' + name + '?';\n}\n\n// bad\nfunction sayHi(name) {\n  return ['How are you, ', name, '?'].join();\n}\n\n// good\nfunction sayHi(name) {\n  return `How are you, ${name}?`;\n</code></pre>\n<h2>函数</h2>\n<ol>\n<li>使用函数声明代替函数表达式</li>\n</ol>\n<blockquote>\n<p>因为函数声明是可命名的, 所以他们在调用栈中更容易\b被识别. \n此外函数声明会把整个函数提升(hoisted), 而函数表达式只会把函数的引用变量名提升. 这条规则是的箭头函数可以取代函数表达式.</p>\n</blockquote>\n<pre><code class=\"language-JavaScript\">// bad\nconst foo = function () {\n};\n\n// good\nfunction foo() {\n}\n</code></pre>\n<ol start=\"2\">\n<li>函数表达式</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// 立即调用的函数表达式(IIFE)\n(() =&gt; {\n    console.log('welcome!')\n})()\n</code></pre>\n<ol start=\"3\">\n<li>不要使用<code>arguments</code>。可以选择<code>rest</code>语法<code>...</code>替代</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// bad\nfunction concatenateAll() {\n  const args = Array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}\n</code></pre>\n<ol start=\"4\">\n<li>直接给函数的参数指定默认值，不要使用一个变化的函数参数。</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// really bad\nfunction handleThings(opts) {\n  // 不！我们不应该改变函数参数。\n  // 更加糟糕: 如果参数 opts 是 false 的话，它就会被设定为一个对象。\n  // 但这样的写法会造成一些 Bugs。\n  //（译注：例如当 opts 被赋值为空字符串，opts 仍然会被下一行代码设定为一个空对象。）\n  opts = opts || {};\n  // ...\n}\n\n// still bad\nfunction handleThings(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // ...\n}\n\n// good\nfunction handleThings(opts = {}) {\n  // ...\n}\n</code></pre>\n<h2>构造器</h2>\n<ol>\n<li>总是使用<code>class</code>, 避免使用<code>prototype</code></li>\n</ol>\n<blockquote>\n<p>因为<code>class</code>语法更易读</p>\n</blockquote>\n<pre><code class=\"language-JavaScript\">// bad\nfunction Queen(contents = []) {\n    this._quene = [...contents];\n}\nQuene.prototype.pop = function() {\n    const value = this._quene[0];\n    this._quene.splice(0, 1);\n    return value;\n}\n\n// good\nclass Queen {\n    constructor(contents = []) {\n        this._quene = [...contents];\n    }\n    pop() {\n        const value = this._quene[0];\n        this._quene.splice(0, 1);\n        return value;\n    }\n}\n</code></pre>\n<h2>Iterators and Generators</h2>\n<ol>\n<li>不要使用<code>iterators</code>, 使用高阶函数如<code>map</code>或者<code>reduce</code>来代替<code>for-of</code></li>\n</ol>\n<pre><code class=\"language-JavaScript\">const numbers = [1, 2, 3, 4, 5];\n\n// bad\nlet sum = 0;\nfor (let num of numbers) {\n  sum += num;\n}\n\nsum === 15;\n\n// good\nlet sum = 0;\nnumbers.forEach((num) =&gt; sum += num);\nsum === 15\n\n// best (use the functional force)\nconst sum = numbers.reduce((total, num) =&gt; total += num, 0)\nsum === 15\n</code></pre>\n<h2>比较运算符和等号</h2>\n<p>条件表达式例如 if 语句通过抽象方法<code>ToBoolean</code>强制计算它们的表达式并且总是遵守下面的规则：</p>\n<ul>\n<li>对象 被计算为 true</li>\n<li>Undefined 被计算为 false</li>\n<li>Null 被计算为 false</li>\n<li>布尔值 被计算为 布尔的值</li>\n<li>数字 如果是 +0、-0、或 NaN 被计算为 false, 否则为 true</li>\n<li>字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true</li>\n</ul>\n<h2>注释</h2>\n<ol>\n<li>给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME – need to figure this out 或者 TODO – need to implement。</li>\n</ol>\n<pre><code class=\"language-JavaScript\">class Calculator {\n  constructor() {\n    // FIXME: shouldn't use a global here\n    total = 0;\n  }\n}\n\nclass Calculator {\n  constructor() {\n    // TODO: total should be configurable by an options param\n    this.total = 0;\n  }\n}\n</code></pre>\n<h2>空白</h2>\n<ol>\n<li>使用2个空格作为缩进。</li>\n<li>在文件末尾插入一个空行。</li>\n</ol>\n<h2>逗号</h2>\n<ol>\n<li>增加结尾的逗号: 需要。</li>\n</ol>\n<blockquote>\n<p><code>JavaScript</code>支持这种做法,并且会自动处理结尾多余的逗号, 好处是会让git diff更干净, 新增字段更方便.\n另外，像 babel 这样的转译器会移除结尾多余的逗号，也就是说你不必担心老旧浏览器的尾逗号问题。</p>\n</blockquote>\n<pre><code class=\"language-JavaScript\">// bad - git diff without trailing comma\nconst hero = {\n     firstName: 'Florence',\n-    lastName: 'Nightingale'\n+    lastName: 'Nightingale',\n+    inventorOf: ['coxcomb graph', 'modern nursing']\n}\n\n// good - git diff with trailing comma\nconst hero = {\n     firstName: 'Florence',\n     lastName: 'Nightingale',\n+    inventorOf: ['coxcomb chart', 'modern nursing'],\n}\n\n// bad\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully'\n};\n\nconst heroes = [\n  'Batman',\n  'Superman'\n];\n\n// good\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully',\n};\n\nconst heroes = [\n  'Batman',\n  'Superman',\n];\n</code></pre>\n<h2>类型转换</h2>\n<ol>\n<li>字符串</li>\n</ol>\n<pre><code class=\"language-JavaScript\">//  =&gt; this.reviewScore = 9;\n\n// bad\nconst totalScore = this.reviewScore + '';\n\n// good\nconst totalScore = String(this.reviewScore);\n</code></pre>\n<ol start=\"2\">\n<li>如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// good\n/**\n * 使用 parseInt 导致我的程序变慢，\n * 改成使用位操作转换数字快多了。\n */\nconst val = inputValue &gt;&gt; 0;\n</code></pre>\n<h2>命名规则</h2>\n<ol>\n<li>别保存<code>this</code>的引用。使用箭头函数或<code>Function#bind</code>。</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// bad\nfunction foo() {\n  const self = this;\n  return function() {\n    console.log(self);\n  };\n}\n\n// bad\nfunction foo() {\n  const that = this;\n  return function() {\n    console.log(that);\n  };\n}\n\n// good\nfunction foo() {\n  return () =&gt; {\n    console.log(this);\n  };\n}\n</code></pre>\n<ol start=\"2\">\n<li>如果你的文件只输出一个类，那你的文件名必须和类名完全保持一致。</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// file contents\nclass CheckBox {\n  // ...\n}\nexport default CheckBox;\n\n// in some other file\n// bad\nimport CheckBox from './checkBox';\n\n// bad\nimport CheckBox from './check_box';\n\n// good\nimport CheckBox from './CheckBox';\n</code></pre>\n<ol start=\"3\">\n<li>当你导出默认的函数时使用驼峰式命名。你的文件名必须和函数名完全保持一致。</li>\n</ol>\n<pre><code class=\"language-JavaScript\">function makeStyleGuide() {\n}\n\nexport default makeStyleGuide;\n</code></pre>\n<ol start=\"4\">\n<li>当你导出单例、函数库、空对象时使用帕斯卡式命名。</li>\n</ol>\n<pre><code class=\"language-JavaScript\">const AirbnbStyleGuide = {\n  es6: {\n  }\n};\n\nexport default AirbnbStyleGuide;\n</code></pre>\n<h2>事件</h2>\n<ol>\n<li>当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。</li>\n</ol>\n<pre><code class=\"language-JavaScript\">// bad\n$(this).trigger('listingUpdated', listing.id);\n\n...\n\n$(this).on('listingUpdated', function(e, listingId) {\n  // do something with listingId\n});\n\n// good\n$(this).trigger('listingUpdated', { listingId : listing.id });\n\n...\n\n$(this).on('listingUpdated', function(e, data) {\n  // do something with data.listingId\n});\n</code></pre>\n","c_time":"2021-11-18 03:05:44","m_time":"2021-11-18 03:05:44"}