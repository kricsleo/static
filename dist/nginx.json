{"path":"nginx","title":"nginx","summary":"nginx 的部署与配置笔记现在很多网站用的都是 nginx 作为代理服务器, 所以为了进行 web 性能的优化, 自然也要折腾一下 nginx 的配置的.我的远程主机环境:# linux 通用查看系","text":"nginx 的部署与配置笔记现在很多网站用的都是 nginx 作为代理服务器, 所以为了进行 web 性能的优化, 自然也要折腾一下 nginx 的配置的.我的远程主机环境:# linux 通用查看系统版本\nlsb_release -a\n# LSB Version:    :core-4.1-amd64:core-4.1-noarch\n# Distributor ID: CentOS\n# Description:    CentOS Linux release 7.4.1708 (Core)\n# Release:        7.4.1708\n# Codename:       Core\nnginx 的安装参考文章: nginx服务器详细安装过程（使用yum 和 源码包两种安装方式，并说明其区别）安装 nginx 前要先安装 nginx 编译及运行的依赖环境# yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel\nnginx 一般来说有两种安装方式: yum安装和源码包自行编译安装, 新手推荐前一种, 想折腾的话或者老手使用后一种yum安装是在线安装, 好处是简单方便, 不易出错, 但是缺点是使用的其实是别人编译好的二进制版本, 不能自定义其中加载的模块, 不过目前来 centos 官方提供的那个版本还是比较实用的# 首先把 nginx 的源加载 yum 里面\nvi /etc/yum.repo.d/nginx.repo\n然后在文件里添加如下内容[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=0\nenabled=1\n然后就可以使用yum install nginx安装最新版了, 也可以yum install nginx-1.6.3安装指定版本.安装之后可以使用rpm -ql nginx查看安装目录, 卸载时使用rpm -e nginx, 如果因为依赖包导致卸载失败，可以尝试rpm -e --nodeps nginx来卸载，这个命令相当于强制卸载，不考虑依赖问题。使用这种方式安装之后 nginx 会被自动添加到系统服务里面, 也就是说可以直接使用serivce nginx {option}来启动或者关闭 nginx.源码包编译安装, 好处是编译的时候是根据你本机的条件和环境进行编译的, 性能更好一些,同时也可以在编译的时候自定义模块# 可以获取指定版本的 nginx, 可以使用 -P 指定下载目录\nwget -c <-P> <destDir> https://nginx.org/download/nginx-1.11.6.tar.gz\n# 然后解压下载的压缩包, 可以使用 -C 指定解压目录\ntar -zxvf nginx-1.11.6.tar.gz <-C> <destDir>\n# 然后进行解压后的目录\ncd nginx-1.11.6\n# 然后先进行编译配置, 直接使用 ./configure 表示使用默认配置, 也可以在后面附加参数表示一些其他的模块之类的, 请具体根据使用来配置\n./configure\n# 然后进行编译安装\nmake && make install\n一般来说编译安装后的二进制文件都在/usr/local/目录下, 如果需要卸载的话直接在这里删除对应的目录就可以, 同时启动 nginx 也可以在这里使用二进制文件直接启动, 见下文 nginx 的使用.使用源码包编译安装的好处是是可以后期为 nginx 添加各种各样的模块.比如我在第一次安装的并没有安装 SSL 相关的模块, 后期我想开启 SSL, 这个时候就需要给 nginx 添加ngx_http_ssl_module模块.注意在添加的时候为了保留之前的一些配置, 我们需要先查看之前编译的configure配置项, 你可以使用./nginx -V来查看, 我的输出如下:nginx version: nginx/1.15.2\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)\nconfigure arguments: --prefix=/usr/local/nginx\n可以看到我的版本是1.15.2, 我之前的编译参数是--prefix=/usr/local/nginx, 也就是只制定了 nginx 的配置文件路径, 那么我现在需要在原来的基础上添加新的参数--with-http_ssl_module才能编译一个新的带有 SSL 模块的 nginx 二进制文件.找到原来的源码包, 没有的话就下载一个跟你现在用的是同一个版本的 nginx 源码包, 然后解压, 进入解压后的目录在解压后的目录执行编译前的配置./configure --prefix=/usr/local/nginx --with-http_ssl_module, 注意这里一定要把你原来的参数都拷贝过来, 然后在后面添加新的, 要不然编译出来的东西可能跟你原来的不兼容接下来执行make, 这里可千万别手快执行make && make install, 如果你insall了那么你之前的 nginx 的配就都丢了, 所以我们这里只需要编译出一个可用的 nginx 的二进制版本, 然后手动替换掉原来的即可.新编译的 nginx 文件在 objs/nginx# 将原来的`/usr/local/nginx/sbin/nginx`备份\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.back\n# 请先停止 nginx 服务, 然后再删除原来的 nginx 文件\nrm -f /usr/local/nginx/sbin/nginx\n# 把新的 nginx 文件拷贝到原来的地方\ncp objs/nginx /usr/local/nginx/sbin/nginx\n然后再正常启动 nginx 即可使得新的功能生效nginx 的使用有两种方式启动 nginx, 但是后一种相对来说方便一些, 推荐使用.直接在安装目录使用 nginx 的命令进行 nginx 的启动和关闭# 启动\n/usr/local/nginx/sbin/nginx\n# 检查默认配置文件\n/usr/nginx/sbin/nginx -t\n# 检查指定配置文件\n/usr/nginx/sbin/nginx -t -c {configFileDir}\n# 使用指定配置文件启动 nginx\n/usr/nginx/sbin/nginx -c {configFileDir}\n# 关闭 stop 表示立即停止, quit 表示平滑停止, reopen 表示重新启动 reload 不中断服务重新加载配置文件\n/usr/local/nginx/sbin/nginx -s {stop|quit|reload|reopen}\n# 通过进程查看及关闭 nginx\nps -ef | grep nginx\n# 从容停止Nginx：\nkill -QUIT 主进程号\n# 快速停止Nginx：\nkill -TERM 主进程号\n# 强制停止Nginx：\nkill -9 nginx\n配置 nginx 的启动和关闭到系统服务在/etc/init.d/目录下新建文件nginx, 把这些内容拷贝到文件中赋予脚本可执行权限chmod +x /etc/init.d/nginx修改系统服务之后使用systemctl daemon-reload重新加载一下才能生效可以吧 nginx 服务配置成开机启动 chkconfig nginx on有如下命令可执行:service nginx {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}\n# 参数说明\n# start 启动 nginx\n# stop 停止 nginx\n# status 查看 nginx 的状态\n# restart 重启 nginx, 会先中断 nginx, 然后重新启动, 如果配置文件有误, 那么将无法启动 nginx\n# reload 重新加载配置文件, 不会中断 nginx 服务, 如果新的配置文件有误, 那么会使用上一次正确的配置文件, 保证服务正常运行\n# configtest 检查配置文件是否正确\nnginx 的配置nginx 的配置相对来说是比较繁杂的, 所以我放到最下面来说, 后期持续补充.参考文档: nginx服务器安装及配置文件详解gzip压缩功能设置gzip 相关配置可放在 http{} 或 server{} 或 location{} 层级，若不同层级有重复设置优先级为 location{} > server{} > http{}gzip 配置参数如下# 打开 gzip 压缩\ngzip on;\n# 进行压缩的最小文件大小, 小于这个大小的不进行压缩\ngzip_min_length 1k;\n# 压缩结果数据流存储所用空间，下面表示以16k为单位，按照原始数据大小以16k为单位的4倍申请内存。默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。\ngzip_buffers    4 16k;\n# 采用http协议版本 默认是1.1 ，对于1.0的请求不会压缩，如果设置成1.0，表示http1.0以上 的版本都会压缩。(如果使用了 proxy_pass 进行反向代理，那么nginx和后端的 upstream server之间默认是用 HTTP/1.0协议通信的。)\ngzip_http_version 1.0;\n# 压缩级别（1~9，一般为平衡文件大小和CPU使用，5是常用值，当然跟实际机器的情况有关） 级别越高, 压缩比越大, 但是 cpu 的性能消耗也越高, 同时在压缩到一定程度之后即使再进行压缩文件体积也不会再有明显的减小了. 一般取值在4~6, 这里有一组测试数据\n; text/html - phpinfo():\n; 0    55.38 KiB (100.00% of original size)\n; 1    11.22 KiB ( 20.26% of original size)\n; 2    10.89 KiB ( 19.66% of original size)\n; 3    10.60 KiB ( 19.14% of original size)\n; 4    10.17 KiB ( 18.36% of original size)\n; 5     9.79 KiB ( 17.68% of original size)\n; 6     9.62 KiB ( 17.37% of original size)\n; 7     9.50 KiB ( 17.15% of original size)\n; 8     9.45 KiB ( 17.06% of original size)\n; 9     9.44 KiB ( 17.05% of original size)\n\n; application/x-javascript - jQuery 1.8.3 (Uncompressed):\n; 0    261.46 KiB (100.00% of original size)\n; 1     95.01 KiB ( 36.34% of original size)\n; 2     90.60 KiB ( 34.65% of original size)\n; 3     87.16 KiB ( 33.36% of original size)\n; 4     81.89 KiB ( 31.32% of original size)\n; 5     79.33 KiB ( 30.34% of original size)\n; 6     78.04 KiB ( 29.85% of original size)\n; 7     77.85 KiB ( 29.78% of original size)\n; 8     77.74 KiB ( 29.73% of original size)\n; 9     77.75 KiB ( 29.74% of original size)\ngzip_comp_level 5;\n# 压缩文件类型（默认总是压缩 text/html类型，其中特别说明的是application/javascript和text/javascript最好都加上，若页面script标签的type不同则有可能发生部分js文件不会压缩，默认type为application/javascript） 一般来说对图片不进行压缩, 因为图片压缩比较耗时而且压缩比也很低\ngzip_types application/atom+xml application/javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/svg+xml image/x-icon text/css text/plain text/javascript text/x-component;\n# 代表缓存压缩和原始版本资源，避免客户端因Accept-Encoding不支持gzip而发生错误的现象（现在一般都采用gzip） 开启此参数以后会在返回头里面看到一个 Vary 字段, 里面会有一个 Accept-Encoding 字段, 代表此资源有着多个版本, 比如 gzip 压缩版 和不压缩版, 关于 Vary 字段的解释可以查看这里: https://imququ.com/post/vary-header-in-http.html\ngzip_vary on;\n# 禁止IE6进行gzip压缩（当然现在已经基本没有人使用IE6了）\ngzip_disable \"MSIE [1-6]\";\n参考文章:Nginx配置指北之gzipHTTPS 配置如果要启用 nginx 的 SSL 配置, 那么需要 nginx 安装的时候包含了http_ssl_module模块, 默认 nginx 是不会安装这个模块的, 可以使用./nginx -V查看 nginx 安装时的配置参数里面有没有这个模块, 如果没有这个模块, 那么我们可以按照上面编译安装的步骤编译一个新的包含这个模块的 nginx 二进制文件, 然后替换掉现在的即可. 然后在 server{} 层级中加入如下配置(请根据自己情况修改)详细配置说明可以查看Nginx 配置 HTTPS 服务器# 网站域名\nserver_name example.com\n# 表示监听 443 端口, 协议为 ssl\nlisten 443 ssl;\n# 证书文件的位置\nssl_certificate     example.com.crt;\n# 证书私钥文件的位置\nssl_certificate_key example.com.key;\n# SSL 协议具体版本\nssl_protocols       TLSv1 TLSv1.1 TLSv1.2;\n# SSL 算法\nssl_ciphers         HIGH:!aNULL:!MD5;\n上面的配置是必须的, 另外还有一些配置依据个人情况可以添加. 另外你需要首先申请自己的网站证书才行.例如安全协议的具体版本ssl_protocols和算法ssl_ciphers, 由于这两个命令的默认值已经好几次发生了改变，因此不建议显性定义，除非有需要额外定义的值，如定义 D-H 算法, 具体查看Nginx 配置 HTTPS 服务器进行配置.HTTP/2.0 配置既然已经上了 HTTPS, 那么干脆一鼓作气上到 HTTP/2.0, 根据规范来说 HTTP/2.0 是不需要依赖 HTTPS 的, 但是目前的现状来说, 各个浏览器都是要求在 HTTPS 的环境中才能启用 HTTP/2.0. nginx 要启用 HTTP/2.0 需要http_v2_module和http_ssl_module这两个模块, 如果之前的编译安装时没有这两个模块, 那么就需要重新加上参数再编译一份. 这里省略我再次编译的过程(同上), 只是编译参数改为./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module.更新了 nginx 之后就要在 nginx 的配置文件里面开启 HTTP/2.0, 告诉客户端我们支持 HTTP/2.0 了. 配置很简单, 只需要在之前的listen字段中增加一个http2即可.目前 IE11+ 以及其他主流浏览器都已经支持 HTTP/2.0, 而且就算客户端不支持结果也是正常的使用现在的 HTTP/1.1, 不会影响页面访问.例如:# 改为\nlisten 443 ssl http2;\n这里有一个小坑, 在启用 HTTP/2.0 之前, 我们可能把80端口和443端口放在同一个 server 里面监听, 但是如果我们想要启用 HTTP/2.0, 那么就必须把80端口拿出去单独放在一个 server 里面, 监听80端口的并不能启用 HTTP/2.0, 所以如果你想要为网站同时启用 HTTP 和 HTTP/2.0, 那么你在 nginx 配置文件里面就至少需要写两个 server, 一个监听80端口, 另一个监听443端口.关于 HTTP/2.0 的相关文章, 尤其是升级及浏览器兼容问题可以查看屈屈的博客谈谈 HTTP/2 的协议协商机制.我自己的总结如下: 在浏览器和服务端建立 TCP 连接之后, 如果是 http 协议, 那么此时就可以进行数据传输了, 如果是 https 协议, 那么就还需要建立安全的 TLS 连接, 由于 TLS 有多个版本, 也有不同的加密算法, 那么浏览器和服务器就需要进行协商, 确定一个版本和算法等信息来进行数据加密, 协商是通过握手来实现的, 首先客户端会发送一个client hello握手信息, 里面包含了客户端支持的各种协议以及算法等信息, 然后服务端收到这个信息之后会在这些支持的协议里面选出自己也支持的协议和算法, 然后确定最后要采用的协议和算法(例如 HTTP/2.0 > HTTP/1.1)通过server hello握手信息返给客户端, 这样双方就确定了一组对应的协议和算法进行后续的数据传输. 所以可以看到服务器在升级到了 HTTP/2.0 之后, 如果用户使用的浏览器也支持 HTTP/2.0, 那么协商之后双方就会无痛升级到 HTTP/2.0 进行通信, 享受 HTTP/2.0 带来的种种好处, 而如果用户的浏览器不支持 HTTP/2.0, 那么协商之后就会采用原来的 HTTP/1.1进行通信, 并不会影响现在的业务.在线检测网站是否支持h3:https://http3check.net 不过目前检测结果我感觉存疑rewrite这一部分主要记录nginx配置中rewrite的使用，背景是这样的，在这一次的折腾（20200610）中，我终于一口气买了阿里云一台5年的服务器，方便之后折腾，然后初步计划是在这台服务器上配置nginx作为各种服务的转发，博客的内容还是markdown，然后编译后生成静态的html等内容放到阿里云OSS上，访问的时候静态内容通过nginx先到CDN，然后CDN回源到OSS，另外估计还会重写整个博客的搜索，预计是在这台服务器上部署一个ES，在前面说到的编译过程中把一些用于检索的内容同步到ES中，同样也会通过nginx来转发搜索服务。解决的第一个点是OSS上的文件内容都是带后缀的，比如index.html，访问的时候需要带上后缀名才能拿到对应的资源，比如https://oss.kricsleo.com/blog/index.html(我这里已经给我的oss绑定了我自己的域名https://oss.kricsleo.com，并且博客相关的内容都放在/blog文件夹下)，但是我想要的是用户访问的时候可以不用输入文件后缀，毕竟带着后缀访问看起来太low了，所以这里就要在nginx代理访问的过程中重写uri，需要满足以下场景：直接访问https://kricsleo.com,重写后变成访问https://oss.kricsleo.com/blog/index.html;直接访问https://kricsleo.com/xxx,重写后变成访问https://oss.kricsleo.com/blog/xxx.html;直接访问https://kricsleo.com/xxx.html,重写后变成访问https://oss.kricsleo.com/blog/xxx.html;直接访问https://kricsleo.com/xxx.css或者其它非html类型资源,重写后变成访问https://oss.kricsleo.com/blog/xxx.css或者其它原本的后缀形式;这里就要用到nginx的rewrite功能了rewrite执行上下文环境：server | location | ifnginx使用ngx_http_rewrite_module模块来提供rewrite相关的功能， 标准格式如下：# rewrite 是指令\n# regex 是 相应的用来匹配访问地址 $request_uri 的正则表达式\n# replacement 是在前面的正则匹配到了之后生成新的访问地址，这里面可以像js里面的正则匹配一样引用前一个表达式的匹配结果\n# 注意如果替换字符串replacement以http：//，https：//或$ scheme开头，则停止处理后续内容，并直接重定向返回给客户端。\n# [flag] 用来指示 rewrite 指令匹配到了之后的进一步操作， 一共有四个选项：last | break | redirect | permanent\n# last：终止处理所处的 location 中的其它 rewrite 指令，并且使用重写后的 uri 立即发起新一轮的 location 匹配\n# break： 终止处理所处的 location 中的其它 rewrite 指令， 但是不会发起新一轮的 location 匹配\n# redirect： 给客户端返回302，让客户端临时重定向到改写后的 uri\n# permanent： 给客户端返回301， 让客户端永久重定向到改写后的 uri\n\n# rewrite regex replacement [flag];\nlocation / {\n    rewrite ^/test1 /test2;\n    rewrite ^/test2 /test3 last;  # 此处发起新一轮location匹配 uri为/test3\n    rewrite ^/test3 /test4;\n    proxy_pass https://google.com;\n}\n\nlocation = /test2 {\n    return 200 \"/test2\";\n}\n\nlocation = /test3 {\n    return 200 \"/test3\";\n}\nlocation = /test4 {\n    return 200 \"/test4\";\n}\n# 发送如下请求\n# curl 127.0.0.1:8080/test1\n# /test3\n\n当如果将上面的 location / 改成如下代码\nlocation / {\n    rewrite ^/test1 /test2;\n    # 此处 不会 发起新一轮location匹配；当是会终止执行后续rewrite模块指令 重写后的uri为 /more/index.html\n    rewrite ^/test2 /more/index.html break;\n    rewrite /more/index\\.html /test4; # 这条指令会被忽略\n\n    # 因为 proxy_pass 不是rewrite模块的指令 所以它不会被 break终止\n    proxy_pass https://google.com;\n}\n# 发送如下请求\n# 浏览器输入 127.0.0.1:8080/test1\n# 代理到 https://google.com/more/index.html;\nrewrite 后的请求参数如果替换字符串replacement包含新的请求参数，则会自动在它们之后附加先前的请求参数。如果你不想要之前的参数，则在替换字符串 replacement 的末尾放置一个问号，避免附加它们。# 由于最后加了个 ?，原来的请求参数将不会被追加到rewrite之后的url后面\nrewrite ^/users/(.*)$ /show?user=$1? last;\n指令执行过程首先顺序执行server块中的rewrite模块指令，得到rewrite后的请求URI；然后循环执行如下两步（如果没有遇到中断循环标志，此循环最多执行10次，但是我们可以使用break指令来中断rewrite后的新一轮的循环）2.1. 依据rewrite后的请求URI，匹配定义的 location 块;2.2. 顺序执行匹配到的 location 中的rewrite模块指令注意nginx的proxy_pass的功能在ngx_http_proxy_module模块中，所以即使ngx_http_rewrite_module模块使用了break或者return方式想要结束执行过程，但是proxy_pass的功能还是会执行，不会受到这个模块的影响if执行上下文环境：server | location使用有如下几种方式(注意 if 后必须跟一个空格，就好像每行语句结尾一定要有;一样，另外 nginx 中没有 else)# 当 $variable 是空字符串或者字符串`\"0\"`的时候判断结果为`false`，其余为`true`\nif ($variable) {\n  #...\n}\n\n# 比较 $variable 与字符串 `'demo'` 是否相等， `$variable != 'demo'`，表示判断不等\nif ($variable = 'demo') {\n  #...\n}\n\n# 变量（只能使用变量，不能使用字符串）与一个正则表达式进行匹配\n# 模式匹配操作符一共有四种：\n# ~：区分大小写的正则匹配\n# ~*：不区分大小写的正则匹配\n# !~: 区分大小写的正则不匹配\n# !~*: 不区分大小写的正则不匹配\nif ($variable ~ ^.*\\.html$) {\n  #...如果变量的值是以`.html`结尾则为 true\n}\n\n# 检查本地是否存在该文件，路径等\n# -f：存在该文件，!-f 不存在该文件，后面可以跟变量或者字符串\n# -d: 存在该路径，!-d 不存在该路径，后面可以跟变量或者字符串\n# -e：检测文件、路径、或者链接文件是否存在，!-e 检测文件、路径、或者链接文件是否不存在，后面可以跟变量或者字符串\n# -x: 检测文件是否为可执行文件，!-x 文件是否为不可执行文件，后面可以跟变量或者字符串\nif (!-f $filename) {\n  #...\n}\nbreak执行上下文环境：server | location | if表示停止执行ngx_http_rewrite_module的指令集，但是其他模块指令是不受影响的例如：server {\n    listen 8080;\n    # 此处 break 会停止执行 server 块的 return 指令(return 指令属于rewrite模块)\n    # 如果把它注释掉 则所有请求进来都返回 ok\n    break;\n    return 200 \"ok\";\n    location = /testbreak {\n        break;\n        return 200 $request_uri;\n        proxy_pass http://127.0.0.1:8080/other;\n    }\n    location / {\n        return 200 $request_uri;\n    }\n}\n\n# 发送请求如下\n# curl 127.0.0.1:8080/testbreak\n# /other\n\n# 可以看到 返回 `/other` 而不是 `/testbreak`，说明 `proxy_pass` 指令还是被执行了\n# 也就是说 其他模块的指令是不会被 break 中断执行的\n# (proxy_pass是ngx_http_proxy_module的指令)\nreturn执行上下文环境：server | location | if停止处理并将指定的code码返回给客户端。 非标准code码 444 关闭连接而不发送响应报头。# 返回 code 和 内容 给客户端\n# return code [text];\nlocation = /ok {\n  return 200 \"ok\";\n}\n\n# 返回 code 和 重定向的 url\n# return code URL;\nlocation = /redirect {\n  return 302 https://google.com;\n}\n# 直接返回重定向的 url（默认302临时重定向）\n# return URL;\nlocation = /redirect {\n    return https://google.com;\n}\nset执行上下文环境：server | location | if设置指定变量的值。变量的值可以包含文本，变量或者是它们的组合形式。location / {\n    set $var1 \"host is \";\n    set $var2 $host;\n    set $var3 \" uri is $request_uri\";\n    return 200 \"response ok $var1$var2$var3\";\n}\n# 发送如下请求\n# curl 127.0.0.1:8080/test\n# response ok host is 127.0.0.1 uri is /test\nrewrite 与 proxy_pass配合使用的一个大坑在实现我上面说的静态文件代理到oss的功能时碰到了这两个指令配合起来使用的一个大坑，这是我没想到的，当rewrite生效以后，proxy_pass中的路径会被忽略掉！举个例子：location / {\n  rewrite ^/(.*) /index.html break;\n  proxy_pass https://oss.kricsleo.com/blog/;\n}\n# 按照我原先的想法，直接访问 https://kricsleo.com 时会先经过rewrite重写然后再拼接到proxy_pass的地址后面，结果应该是 https://oss.kricsleo.com/blog/index.html\n# 但是实际上并非如此！最后结果是 https://oss.kricsleo.com/index.html，proxy_pass中的路径 /blog 会被忽略掉，\n# 所以要想达到目的需要把路径 /blog 加到rewrite的结果里面去，才能路径才不会丢失，如下所示，最开始查资料的时候没看到任何一个资料提到这一点，但是反反复复排查为什么会产生404（因为最后的 uri 地址其实是丢失路径的，所以一直404）的过程中，偶然看到一句 「proxy_pass路径无效」然后往这个方向排查了一下才发现问题，难顶。。。\nlocation / {\n  rewrite ^/(.*) /blog/index.html break;\n  proxy_pass https://oss.kricsleo.com;\n}\n\n这里附上我最后使用的满足前面提出的四个场景的配置语句\nlocation / {\n  # 把通用路径放到变量里面，后面直接引用\n  set $prefix '/blog';\n\n  # 如果是直接访问域名的方式，https://kricsleo.com, 则重写 uri 为 https://kricsleo.com/blog/index.html,\n  if ( $request_uri ~ ^/$ ) {\n      rewrite ^/(.*) $prefix/index.html break;\n  }\n\n  # 如果访问路径没有带后缀， 则自动拼接上 .html 后缀（如果已经带后缀，例如 .css 等则此处不作处理）\n  if ( $request_uri !~* ^/(.*)\\.(.*)$ ) {\n    rewrite ^/(.*) $prefix/$1.html break;\n  }\n\n  # 不属于上面两种情况的统一就直接重写拼接我的 oss 路径 /blog 即可\n  rewrite ^/(.*) $prefix/$1 break;\n\n  # rewrite 结束后统一使用 proxy_pass 代理的真实 oss 服务\n  proxy_pass https://oss.kricsleo.com;\n}\n","html":"<h1>nginx 的部署与配置笔记</h1>\n<p>现在很多网站用的都是 nginx 作为代理服务器, 所以为了进行 web 性能的优化, 自然也要折腾一下 nginx 的配置的.</p>\n<!-- more -->\n<p>我的远程主机环境:</p>\n<pre><code class=\"language-bash\"># linux 通用查看系统版本\nlsb_release -a\n# LSB Version:    :core-4.1-amd64:core-4.1-noarch\n# Distributor ID: CentOS\n# Description:    CentOS Linux release 7.4.1708 (Core)\n# Release:        7.4.1708\n# Codename:       Core\n</code></pre>\n<h2>nginx 的安装</h2>\n<p>参考文章: <a href=\"https://segmentfault.com/a/1190000007116797\">nginx服务器详细安装过程（使用yum 和 源码包两种安装方式，并说明其区别）</a></p>\n<p>安装 nginx 前要先安装 nginx 编译及运行的依赖环境</p>\n<pre><code class=\"language-bash\"># yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel\n</code></pre>\n<p>nginx 一般来说有两种安装方式: <code>yum</code>安装和源码包自行编译安装, 新手推荐前一种, 想折腾的话或者老手使用后一种</p>\n<ul>\n<li><code>yum</code>安装是在线安装, 好处是简单方便, 不易出错, 但是缺点是使用的其实是别人编译好的二进制版本, 不能自定义其中加载的模块, 不过目前来 centos 官方提供的那个版本还是比较实用的</li>\n</ul>\n<pre><code class=\"language-bash\"># 首先把 nginx 的源加载 yum 里面\nvi /etc/yum.repo.d/nginx.repo\n</code></pre>\n<p>然后在文件里添加如下内容</p>\n<pre><code class=\"language-conf\">[nginx]\nname=nginx repo\nbaseurl=http://nginx.org/packages/centos/$releasever/$basearch/\ngpgcheck=0\nenabled=1\n</code></pre>\n<p>然后就可以使用<code>yum install nginx</code>安装最新版了, 也可以<code>yum install nginx-1.6.3</code>安装指定版本.安装之后可以使用<code>rpm -ql nginx</code>查看安装目录, 卸载时使用<code>rpm -e nginx</code>, 如果因为依赖包导致卸载失败，可以尝试<code>rpm -e --nodeps nginx</code>来卸载，这个命令相当于强制卸载，不考虑依赖问题。</p>\n<p>使用这种方式安装之后 nginx 会被自动添加到系统服务里面, 也就是说可以直接使用<code>serivce nginx {option}</code>来启动或者关闭 nginx.</p>\n<ul>\n<li>源码包编译安装, 好处是编译的时候是根据你本机的条件和环境进行编译的, 性能更好一些,同时也可以在编译的时候自定义模块</li>\n</ul>\n<pre><code class=\"language-bash\"># 可以获取指定版本的 nginx, 可以使用 -P 指定下载目录\nwget -c &lt;-P&gt; &lt;destDir&gt; https://nginx.org/download/nginx-1.11.6.tar.gz\n# 然后解压下载的压缩包, 可以使用 -C 指定解压目录\ntar -zxvf nginx-1.11.6.tar.gz &lt;-C&gt; &lt;destDir&gt;\n# 然后进行解压后的目录\ncd nginx-1.11.6\n# 然后先进行编译配置, 直接使用 ./configure 表示使用默认配置, 也可以在后面附加参数表示一些其他的模块之类的, 请具体根据使用来配置\n./configure\n# 然后进行编译安装\nmake &amp;&amp; make install\n</code></pre>\n<p>一般来说编译安装后的二进制文件都在<code>/usr/local/</code>目录下, 如果需要卸载的话直接在这里删除对应的目录就可以, 同时启动 nginx 也可以在这里使用二进制文件直接启动, 见下文 nginx 的使用.</p>\n<p>使用源码包编译安装的好处是是可以后期为 nginx 添加各种各样的模块.</p>\n<p>比如我在第一次安装的并没有安装 SSL 相关的模块, 后期我想开启 SSL, 这个时候就需要给 nginx 添加<code>ngx_http_ssl_module</code>模块.\n注意在添加的时候为了保留之前的一些配置, 我们需要先查看之前编译的<code>configure</code>配置项, 你可以使用<code>./nginx -V</code>来查看, 我的输出如下:</p>\n<pre><code class=\"language-text\">nginx version: nginx/1.15.2\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC)\nconfigure arguments: --prefix=/usr/local/nginx\n</code></pre>\n<p>可以看到我的版本是<code>1.15.2</code>, 我之前的编译参数是<code>--prefix=/usr/local/nginx</code>, 也就是只制定了 nginx 的配置文件路径, 那么我现在需要在原来的基础上添加新的参数<code>--with-http_ssl_module</code>才能编译一个新的带有 SSL 模块的 nginx 二进制文件.</p>\n<ol>\n<li>找到原来的源码包, 没有的话就下载一个跟你现在用的是同一个版本的 nginx 源码包, 然后解压, 进入解压后的目录</li>\n<li>在解压后的目录执行编译前的配置<code>./configure --prefix=/usr/local/nginx --with-http_ssl_module</code>, 注意这里一定要把你原来的参数都拷贝过来, 然后在后面添加新的, 要不然编译出来的东西可能跟你原来的不兼容</li>\n<li>接下来执行<code>make</code>, <strong>这里可千万别手快执行<code>make &amp;&amp; make install</code></strong>, 如果你<code>insall</code>了那么你之前的 nginx 的配就都丢了, 所以我们这里只需要编译出一个可用的 nginx 的二进制版本, 然后手动替换掉原来的即可.</li>\n<li>新编译的 nginx 文件在 <code>objs/nginx</code></li>\n</ol>\n<pre><code class=\"language-bash\"># 将原来的`/usr/local/nginx/sbin/nginx`备份\ncp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.back\n# 请先停止 nginx 服务, 然后再删除原来的 nginx 文件\nrm -f /usr/local/nginx/sbin/nginx\n# 把新的 nginx 文件拷贝到原来的地方\ncp objs/nginx /usr/local/nginx/sbin/nginx\n</code></pre>\n<p>然后再正常启动 nginx 即可使得新的功能生效</p>\n<h2>nginx 的使用</h2>\n<p>有两种方式启动 nginx, 但是后一种相对来说方便一些, 推荐使用.</p>\n<ul>\n<li>直接在安装目录使用 nginx 的命令进行 nginx 的启动和关闭</li>\n</ul>\n<pre><code class=\"language-bash\"># 启动\n/usr/local/nginx/sbin/nginx\n# 检查默认配置文件\n/usr/nginx/sbin/nginx -t\n# 检查指定配置文件\n/usr/nginx/sbin/nginx -t -c {configFileDir}\n# 使用指定配置文件启动 nginx\n/usr/nginx/sbin/nginx -c {configFileDir}\n# 关闭 stop 表示立即停止, quit 表示平滑停止, reopen 表示重新启动 reload 不中断服务重新加载配置文件\n/usr/local/nginx/sbin/nginx -s {stop|quit|reload|reopen}\n# 通过进程查看及关闭 nginx\nps -ef | grep nginx\n# 从容停止Nginx：\nkill -QUIT 主进程号\n# 快速停止Nginx：\nkill -TERM 主进程号\n# 强制停止Nginx：\nkill -9 nginx\n</code></pre>\n<ul>\n<li>配置 nginx 的启动和关闭到系统服务</li>\n</ul>\n<ol>\n<li>在<code>/etc/init.d/</code>目录下新建文件<code>nginx</code>, 把<a href=\"/code/nginx\">这些内容</a>拷贝到文件中</li>\n<li>赋予脚本可执行权限<code>chmod +x /etc/init.d/nginx</code></li>\n<li>修改系统服务之后使用<code>systemctl daemon-reload</code>重新加载一下才能生效</li>\n<li>可以吧 nginx 服务配置成开机启动 <code>chkconfig nginx on</code></li>\n<li>有如下命令可执行:</li>\n</ol>\n<pre><code class=\"language-bash\">service nginx {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}\n# 参数说明\n# start 启动 nginx\n# stop 停止 nginx\n# status 查看 nginx 的状态\n# restart 重启 nginx, 会先中断 nginx, 然后重新启动, 如果配置文件有误, 那么将无法启动 nginx\n# reload 重新加载配置文件, 不会中断 nginx 服务, 如果新的配置文件有误, 那么会使用上一次正确的配置文件, 保证服务正常运行\n# configtest 检查配置文件是否正确\n</code></pre>\n<h2>nginx 的配置</h2>\n<p>nginx 的配置相对来说是比较繁杂的, 所以我放到最下面来说, 后期持续补充.\n参考文档: <a href=\"https://segmentfault.com/a/1190000002797601\">nginx服务器安装及配置文件详解</a></p>\n<h3>gzip压缩功能设置</h3>\n<p>gzip 相关配置可放在 http{} 或 server{} 或 location{} 层级，若不同层级有重复设置优先级为 location{} &gt; server{} &gt; http{}\ngzip 配置参数如下</p>\n<pre><code class=\"language-conf\"># 打开 gzip 压缩\ngzip on;\n# 进行压缩的最小文件大小, 小于这个大小的不进行压缩\ngzip_min_length 1k;\n# 压缩结果数据流存储所用空间，下面表示以16k为单位，按照原始数据大小以16k为单位的4倍申请内存。默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。\ngzip_buffers    4 16k;\n# 采用http协议版本 默认是1.1 ，对于1.0的请求不会压缩，如果设置成1.0，表示http1.0以上 的版本都会压缩。(如果使用了 proxy_pass 进行反向代理，那么nginx和后端的 upstream server之间默认是用 HTTP/1.0协议通信的。)\ngzip_http_version 1.0;\n# 压缩级别（1~9，一般为平衡文件大小和CPU使用，5是常用值，当然跟实际机器的情况有关） 级别越高, 压缩比越大, 但是 cpu 的性能消耗也越高, 同时在压缩到一定程度之后即使再进行压缩文件体积也不会再有明显的减小了. 一般取值在4~6, 这里有一组测试数据\n; text/html - phpinfo():\n; 0    55.38 KiB (100.00% of original size)\n; 1    11.22 KiB ( 20.26% of original size)\n; 2    10.89 KiB ( 19.66% of original size)\n; 3    10.60 KiB ( 19.14% of original size)\n; 4    10.17 KiB ( 18.36% of original size)\n; 5     9.79 KiB ( 17.68% of original size)\n; 6     9.62 KiB ( 17.37% of original size)\n; 7     9.50 KiB ( 17.15% of original size)\n; 8     9.45 KiB ( 17.06% of original size)\n; 9     9.44 KiB ( 17.05% of original size)\n\n; application/x-javascript - jQuery 1.8.3 (Uncompressed):\n; 0    261.46 KiB (100.00% of original size)\n; 1     95.01 KiB ( 36.34% of original size)\n; 2     90.60 KiB ( 34.65% of original size)\n; 3     87.16 KiB ( 33.36% of original size)\n; 4     81.89 KiB ( 31.32% of original size)\n; 5     79.33 KiB ( 30.34% of original size)\n; 6     78.04 KiB ( 29.85% of original size)\n; 7     77.85 KiB ( 29.78% of original size)\n; 8     77.74 KiB ( 29.73% of original size)\n; 9     77.75 KiB ( 29.74% of original size)\ngzip_comp_level 5;\n# 压缩文件类型（默认总是压缩 text/html类型，其中特别说明的是application/javascript和text/javascript最好都加上，若页面script标签的type不同则有可能发生部分js文件不会压缩，默认type为application/javascript） 一般来说对图片不进行压缩, 因为图片压缩比较耗时而且压缩比也很低\ngzip_types application/atom+xml application/javascript application/json application/rss+xml application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/svg+xml image/x-icon text/css text/plain text/javascript text/x-component;\n# 代表缓存压缩和原始版本资源，避免客户端因Accept-Encoding不支持gzip而发生错误的现象（现在一般都采用gzip） 开启此参数以后会在返回头里面看到一个 Vary 字段, 里面会有一个 Accept-Encoding 字段, 代表此资源有着多个版本, 比如 gzip 压缩版 和不压缩版, 关于 Vary 字段的解释可以查看这里: https://imququ.com/post/vary-header-in-http.html\ngzip_vary on;\n# 禁止IE6进行gzip压缩（当然现在已经基本没有人使用IE6了）\ngzip_disable &quot;MSIE [1-6]&quot;;\n</code></pre>\n<p>参考文章:<a href=\"https://segmentfault.com/a/1190000010563519\">Nginx配置指北之gzip</a></p>\n<h3>HTTPS 配置</h3>\n<p>如果要启用 nginx 的 SSL 配置, 那么需要 nginx 安装的时候包含了<code>http_ssl_module</code>模块, 默认 nginx 是不会安装这个模块的, 可以使用<code>./nginx -V</code>查看 nginx 安装时的配置参数里面有没有这个模块, 如果没有这个模块, 那么我们可以按照上面编译安装的步骤编译一个新的包含这个模块的 nginx 二进制文件, 然后替换掉现在的即可. 然后在 server{} 层级中加入如下配置(请根据自己情况修改)</p>\n<p>详细配置说明可以查看<a href=\"https://aotu.io/notes/2016/08/16/nginx-https/index.html\">Nginx 配置 HTTPS 服务器</a></p>\n<pre><code class=\"language-conf\"># 网站域名\nserver_name example.com\n# 表示监听 443 端口, 协议为 ssl\nlisten 443 ssl;\n# 证书文件的位置\nssl_certificate     example.com.crt;\n# 证书私钥文件的位置\nssl_certificate_key example.com.key;\n# SSL 协议具体版本\nssl_protocols       TLSv1 TLSv1.1 TLSv1.2;\n# SSL 算法\nssl_ciphers         HIGH:!aNULL:!MD5;\n</code></pre>\n<p>上面的配置是必须的, 另外还有一些配置依据个人情况可以添加. 另外你需要首先申请自己的网站证书才行.</p>\n<p>例如安全协议的具体版本<code>ssl_protocols</code>和算法<code>ssl_ciphers</code>, 由于这两个命令的默认值已经好几次发生了改变，因此不建议显性定义，除非有需要额外定义的值，如定义 D-H 算法, 具体查看<a href=\"https://aotu.io/notes/2016/08/16/nginx-https/index.html\">Nginx 配置 HTTPS 服务器</a>进行配置.</p>\n<h3>HTTP/2.0 配置</h3>\n<p>既然已经上了 HTTPS, 那么干脆一鼓作气上到 HTTP/2.0, 根据规范来说 HTTP/2.0 是不需要依赖 HTTPS 的, 但是目前的现状来说, 各个浏览器都是要求在 HTTPS 的环境中才能启用 HTTP/2.0. nginx 要启用 HTTP/2.0 需要<code>http_v2_module</code>和<code>http_ssl_module</code>这两个模块, 如果之前的编译安装时没有这两个模块, 那么就需要重新加上参数再编译一份. 这里省略我再次编译的过程(同上), 只是编译参数改为<code>./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module</code>.</p>\n<p>更新了 nginx 之后就要在 nginx 的配置文件里面开启 HTTP/2.0, 告诉客户端我们支持 HTTP/2.0 了. 配置很简单, 只需要在之前的<code>listen</code>字段中增加一个<code>http2</code>即可.</p>\n<p>目前 IE11+ 以及其他主流浏览器都已经支持 HTTP/2.0, 而且就算客户端不支持结果也是正常的使用现在的 HTTP/1.1, 不会影响页面访问.</p>\n<p>例如:</p>\n<pre><code class=\"language-conf\"># 改为\nlisten 443 ssl http2;\n</code></pre>\n<p>这里有一个<strong>小坑</strong>, 在启用 HTTP/2.0 之前, 我们可能把80端口和443端口放在同一个 server 里面监听, 但是如果我们想要启用 HTTP/2.0, 那么就必须把80端口拿出去单独放在一个 server 里面, 监听80端口的并不能启用 HTTP/2.0, 所以如果你想要为网站同时启用 HTTP 和 HTTP/2.0, 那么你在 nginx 配置文件里面就至少需要写两个 server, 一个监听80端口, 另一个监听443端口.</p>\n<p>关于 HTTP/2.0 的相关文章, 尤其是升级及浏览器兼容问题可以查看屈屈的博客<a href=\"https://imququ.com/post/protocol-negotiation-in-http2.html\">谈谈 HTTP/2 的协议协商机制</a>.</p>\n<p>我自己的总结如下: 在浏览器和服务端建立 TCP 连接之后, 如果是 http 协议, 那么此时就可以进行数据传输了, 如果是 https 协议, 那么就还需要建立安全的 TLS 连接, 由于 TLS 有多个版本, 也有不同的加密算法, 那么浏览器和服务器就需要进行协商, 确定一个版本和算法等信息来进行数据加密, 协商是通过<code>握手</code>来实现的, 首先客户端会发送一个<code>client hello</code>握手信息, 里面包含了客户端支持的各种协议以及算法等信息, 然后服务端收到这个信息之后会在这些支持的协议里面选出自己也支持的协议和算法, 然后确定最后要采用的协议和算法(例如 HTTP/2.0 &gt; HTTP/1.1)通过<code>server hello</code>握手信息返给客户端, 这样双方就确定了一组对应的协议和算法进行后续的数据传输. 所以可以看到服务器在升级到了 HTTP/2.0 之后, 如果用户使用的浏览器也支持 HTTP/2.0, 那么协商之后双方就会无痛升级到 HTTP/2.0 进行通信, 享受 HTTP/2.0 带来的种种好处, 而如果用户的浏览器不支持 HTTP/2.0, 那么协商之后就会采用原来的 HTTP/1.1进行通信, 并不会影响现在的业务.</p>\n<p>在线检测网站是否支持h3:https://http3check.net 不过目前检测结果我感觉存疑</p>\n<h2><code>rewrite</code></h2>\n<p>这一部分主要记录<code>nginx</code>配置中<code>rewrite</code>的使用，背景是这样的，在这一次的折腾（20200610）中，我终于一口气买了阿里云一台5年的服务器，方便之后折腾，然后初步计划是在这台服务器上配置<code>nginx</code>作为各种服务的转发，博客的内容还是<code>markdown</code>，然后编译后生成静态的<code>html</code>等内容放到阿里云OSS上，访问的时候静态内容通过<code>nginx</code>先到CDN，然后CDN回源到OSS，另外估计还会重写整个博客的搜索，预计是在这台服务器上部署一个ES，在前面说到的编译过程中把一些用于检索的内容同步到ES中，同样也会通过<code>nginx</code>来转发搜索服务。</p>\n<p>解决的第一个点是OSS上的文件内容都是带后缀的，比如<code>index.html</code>，访问的时候需要带上后缀名才能拿到对应的资源，比如<code>https://oss.kricsleo.com/blog/index.html</code>(我这里已经给我的oss绑定了我自己的域名<code>https://oss.kricsleo.com</code>，并且博客相关的内容都放在<code>/blog</code>文件夹下)，但是我想要的是用户访问的时候可以不用输入文件后缀，毕竟带着后缀访问看起来太low了，所以这里就要在<code>nginx</code>代理访问的过程中重写<code>uri</code>，需要满足以下场景：</p>\n<ul>\n<li>直接访问<code>https://kricsleo.com</code>,重写后变成访问<code>https://oss.kricsleo.com/blog/index.html</code>;</li>\n<li>直接访问<code>https://kricsleo.com/xxx</code>,重写后变成访问<code>https://oss.kricsleo.com/blog/xxx.html</code>;</li>\n<li>直接访问<code>https://kricsleo.com/xxx.html</code>,重写后变成访问<code>https://oss.kricsleo.com/blog/xxx.html</code>;</li>\n<li>直接访问<code>https://kricsleo.com/xxx.css</code>或者其它非<code>html</code>类型资源,重写后变成访问<code>https://oss.kricsleo.com/blog/xxx.css</code>或者其它原本的后缀形式;</li>\n</ul>\n<p>这里就要用到<code>nginx</code>的<code>rewrite</code>功能了</p>\n<h3><code>rewrite</code></h3>\n<ul>\n<li>执行上下文环境：<code>server</code> | <code>location</code> | <code>if</code></li>\n</ul>\n<p><code>nginx</code>使用<code>ngx_http_rewrite_module</code>模块来提供<code>rewrite</code>相关的功能， 标准格式如下：</p>\n<pre><code class=\"language-nginx.conf\"># rewrite 是指令\n# regex 是 相应的用来匹配访问地址 $request_uri 的正则表达式\n# replacement 是在前面的正则匹配到了之后生成新的访问地址，这里面可以像js里面的正则匹配一样引用前一个表达式的匹配结果\n# 注意如果替换字符串replacement以http：//，https：//或$ scheme开头，则停止处理后续内容，并直接重定向返回给客户端。\n# [flag] 用来指示 rewrite 指令匹配到了之后的进一步操作， 一共有四个选项：last | break | redirect | permanent\n# last：终止处理所处的 location 中的其它 rewrite 指令，并且使用重写后的 uri 立即发起新一轮的 location 匹配\n# break： 终止处理所处的 location 中的其它 rewrite 指令， 但是不会发起新一轮的 location 匹配\n# redirect： 给客户端返回302，让客户端临时重定向到改写后的 uri\n# permanent： 给客户端返回301， 让客户端永久重定向到改写后的 uri\n\n# rewrite regex replacement [flag];\n</code></pre>\n<pre><code class=\"language-nginx.conf\">location / {\n    rewrite ^/test1 /test2;\n    rewrite ^/test2 /test3 last;  # 此处发起新一轮location匹配 uri为/test3\n    rewrite ^/test3 /test4;\n    proxy_pass https://google.com;\n}\n\nlocation = /test2 {\n    return 200 &quot;/test2&quot;;\n}\n\nlocation = /test3 {\n    return 200 &quot;/test3&quot;;\n}\nlocation = /test4 {\n    return 200 &quot;/test4&quot;;\n}\n# 发送如下请求\n# curl 127.0.0.1:8080/test1\n# /test3\n\n当如果将上面的 location / 改成如下代码\nlocation / {\n    rewrite ^/test1 /test2;\n    # 此处 不会 发起新一轮location匹配；当是会终止执行后续rewrite模块指令 重写后的uri为 /more/index.html\n    rewrite ^/test2 /more/index.html break;\n    rewrite /more/index\\.html /test4; # 这条指令会被忽略\n\n    # 因为 proxy_pass 不是rewrite模块的指令 所以它不会被 break终止\n    proxy_pass https://google.com;\n}\n# 发送如下请求\n# 浏览器输入 127.0.0.1:8080/test1\n# 代理到 https://google.com/more/index.html;\n</code></pre>\n<ul>\n<li><code>rewrite</code> 后的请求参数\n如果替换字符串replacement包含新的请求参数，则会自动在它们之后附加先前的请求参数。如果你不想要之前的参数，则在替换字符串 replacement 的末尾放置一个问号，避免附加它们。</li>\n</ul>\n<pre><code class=\"language-nginx.conf\"># 由于最后加了个 ?，原来的请求参数将不会被追加到rewrite之后的url后面\nrewrite ^/users/(.*)$ /show?user=$1? last;\n</code></pre>\n<h3>指令执行过程</h3>\n<ol>\n<li>首先顺序执行server块中的rewrite模块指令，得到rewrite后的请求URI；</li>\n<li>然后循环执行如下两步（如果没有遇到中断循环标志，此循环最多执行10次，但是我们可以使用<code>break</code>指令来中断rewrite后的新一轮的循环）\n2.1. 依据rewrite后的请求URI，匹配定义的 location 块;\n2.2. 顺序执行匹配到的 location 中的rewrite模块指令</li>\n</ol>\n<p>注意<code>nginx</code>的<code>proxy_pass</code>的功能在<code>ngx_http_proxy_module</code>模块中，所以即使<code>ngx_http_rewrite_module</code>模块使用了<code>break</code>或者<code>return</code>方式想要结束执行过程，但是<code>proxy_pass</code>的功能还是会执行，不会受到这个模块的影响</p>\n<h3><code>if</code></h3>\n<ul>\n<li>执行上下文环境：<code>server</code> | <code>location</code></li>\n<li>使用有如下几种方式(注意 <code>if</code> 后必须跟一个空格，就好像每行语句结尾一定要有<code>;</code>一样，另外 <code>nginx</code> 中没有 <code>else</code>)</li>\n</ul>\n<pre><code class=\"language-nginx.conf\"># 当 $variable 是空字符串或者字符串`&quot;0&quot;`的时候判断结果为`false`，其余为`true`\nif ($variable) {\n  #...\n}\n\n# 比较 $variable 与字符串 `'demo'` 是否相等， `$variable != 'demo'`，表示判断不等\nif ($variable = 'demo') {\n  #...\n}\n\n# 变量（只能使用变量，不能使用字符串）与一个正则表达式进行匹配\n# 模式匹配操作符一共有四种：\n# ~：区分大小写的正则匹配\n# ~*：不区分大小写的正则匹配\n# !~: 区分大小写的正则不匹配\n# !~*: 不区分大小写的正则不匹配\nif ($variable ~ ^.*\\.html$) {\n  #...如果变量的值是以`.html`结尾则为 true\n}\n\n# 检查本地是否存在该文件，路径等\n# -f：存在该文件，!-f 不存在该文件，后面可以跟变量或者字符串\n# -d: 存在该路径，!-d 不存在该路径，后面可以跟变量或者字符串\n# -e：检测文件、路径、或者链接文件是否存在，!-e 检测文件、路径、或者链接文件是否不存在，后面可以跟变量或者字符串\n# -x: 检测文件是否为可执行文件，!-x 文件是否为不可执行文件，后面可以跟变量或者字符串\nif (!-f $filename) {\n  #...\n}\n</code></pre>\n<h3><code>break</code></h3>\n<ul>\n<li>执行上下文环境：<code>server</code> | <code>location</code> | <code>if</code></li>\n<li>表示停止执行<code>ngx_http_rewrite_module</code>的指令集，但是其他模块指令是不受影响的</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"language-nginx.conf\">server {\n    listen 8080;\n    # 此处 break 会停止执行 server 块的 return 指令(return 指令属于rewrite模块)\n    # 如果把它注释掉 则所有请求进来都返回 ok\n    break;\n    return 200 &quot;ok&quot;;\n    location = /testbreak {\n        break;\n        return 200 $request_uri;\n        proxy_pass http://127.0.0.1:8080/other;\n    }\n    location / {\n        return 200 $request_uri;\n    }\n}\n\n# 发送请求如下\n# curl 127.0.0.1:8080/testbreak\n# /other\n\n# 可以看到 返回 `/other` 而不是 `/testbreak`，说明 `proxy_pass` 指令还是被执行了\n# 也就是说 其他模块的指令是不会被 break 中断执行的\n# (proxy_pass是ngx_http_proxy_module的指令)\n</code></pre>\n<h3><code>return</code></h3>\n<ul>\n<li>执行上下文环境：<code>server</code> | <code>location</code> | <code>if</code></li>\n<li>停止处理并将指定的code码返回给客户端。 非标准code码 444 关闭连接而不发送响应报头。</li>\n</ul>\n<pre><code class=\"language-nginx.conf\"># 返回 code 和 内容 给客户端\n# return code [text];\nlocation = /ok {\n  return 200 &quot;ok&quot;;\n}\n\n# 返回 code 和 重定向的 url\n# return code URL;\nlocation = /redirect {\n  return 302 https://google.com;\n}\n# 直接返回重定向的 url（默认302临时重定向）\n# return URL;\nlocation = /redirect {\n    return https://google.com;\n}\n</code></pre>\n<h3><code>set</code></h3>\n<ul>\n<li>执行上下文环境：<code>server</code> | <code>location</code> | <code>if</code></li>\n<li>设置指定变量的值。变量的值可以包含文本，变量或者是它们的组合形式。</li>\n</ul>\n<pre><code class=\"language-nginx.conf\">location / {\n    set $var1 &quot;host is &quot;;\n    set $var2 $host;\n    set $var3 &quot; uri is $request_uri&quot;;\n    return 200 &quot;response ok $var1$var2$var3&quot;;\n}\n# 发送如下请求\n# curl 127.0.0.1:8080/test\n# response ok host is 127.0.0.1 uri is /test\n</code></pre>\n<h3><code>rewrite</code> 与 <code>proxy_pass</code>配合使用的一个大坑</h3>\n<p>在实现我上面说的静态文件代理到oss的功能时碰到了这两个指令配合起来使用的一个大坑，这是我没想到的，当<code>rewrite</code>生效以后，<code>proxy_pass</code>中的路径会被忽略掉！\n举个例子：</p>\n<pre><code class=\"language-nginx.conf\">location / {\n  rewrite ^/(.*) /index.html break;\n  proxy_pass https://oss.kricsleo.com/blog/;\n}\n# 按照我原先的想法，直接访问 https://kricsleo.com 时会先经过rewrite重写然后再拼接到proxy_pass的地址后面，结果应该是 https://oss.kricsleo.com/blog/index.html\n# 但是实际上并非如此！最后结果是 https://oss.kricsleo.com/index.html，proxy_pass中的路径 /blog 会被忽略掉，\n# 所以要想达到目的需要把路径 /blog 加到rewrite的结果里面去，才能路径才不会丢失，如下所示，最开始查资料的时候没看到任何一个资料提到这一点，但是反反复复排查为什么会产生404（因为最后的 uri 地址其实是丢失路径的，所以一直404）的过程中，偶然看到一句 「proxy_pass路径无效」然后往这个方向排查了一下才发现问题，难顶。。。\nlocation / {\n  rewrite ^/(.*) /blog/index.html break;\n  proxy_pass https://oss.kricsleo.com;\n}\n\n这里附上我最后使用的满足前面提出的四个场景的配置语句\nlocation / {\n  # 把通用路径放到变量里面，后面直接引用\n  set $prefix '/blog';\n\n  # 如果是直接访问域名的方式，https://kricsleo.com, 则重写 uri 为 https://kricsleo.com/blog/index.html,\n  if ( $request_uri ~ ^/$ ) {\n      rewrite ^/(.*) $prefix/index.html break;\n  }\n\n  # 如果访问路径没有带后缀， 则自动拼接上 .html 后缀（如果已经带后缀，例如 .css 等则此处不作处理）\n  if ( $request_uri !~* ^/(.*)\\.(.*)$ ) {\n    rewrite ^/(.*) $prefix/$1.html break;\n  }\n\n  # 不属于上面两种情况的统一就直接重写拼接我的 oss 路径 /blog 即可\n  rewrite ^/(.*) $prefix/$1 break;\n\n  # rewrite 结束后统一使用 proxy_pass 代理的真实 oss 服务\n  proxy_pass https://oss.kricsleo.com;\n}\n</code></pre>\n","c_time":"2021-11-18 03:05:44","m_time":"2021-11-18 03:05:44"}