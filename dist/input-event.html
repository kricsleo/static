<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>input-event</title>
  <link rel="stylesheet" href="https://oss.kricsleo.com/github.min.css" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="article">
    <div class="sidebar">
      <img src="https://oss.kricsleo.com/avatar.jpg" class="sidebar__avatar">
      <input class="sidebar__input" id="sidebar__input" type="text" placeholder="type something" autofocus>
      <ul class="sidebar__input-result" id="sidebar__input-result"></ul>
      <p class="sidebar__copyright">
        @<a href="/">kricleo.com</a>
      </p>
    </div>
    <div class="article__wrapper">
      <div class="article__viewport">
        <div class="article__content">
          <h1>input 元素的事件顺序</h1>
<p>h5 的<code>&lt;input /&gt;</code>组件上有很多的事件, 这次来详细的探究一下它们的触发顺序和使用场景</p>
<!-- more -->
<p>我的测试是在 chrome 版本 73.0.3683.75（正式版本）（64 位）环境, 其它的浏览器可能有不同, 有时间再补充其它浏览器吧.</p>
<p>目前来说比较常用的有<code>focus</code>/<code>keydown</code>/<code>input</code>/<code>keyup</code>/<code>compositionstart</code>/<code>compositionupdate</code>/<code>compositionend</code>/<code>change</code> </p>
<p>点击一个输入框开始输入触发的事件顺序依次是: </p>
<p><code>focus</code>=&gt;<code>keydown</code>(=&gt;<code>compositionstart</code>=&gt;<code>compositionupdate</code>)=&gt;<code>input</code>(=&gt;<code>compositionend</code>)=&gt;<code>keyup</code></p>
<p>如果是组合输入(比如中文日文等)输入的话就会出现括号中组合输入事件, 详细来说是当开始输入中文的时候就会触发<code>compositionstart</code>事件, 此时<code>input</code>事件和<code>keyup</code>事件拿到的输入框的值是不完整的(一般包含你输入的拼音和拼音之间的分号), 当中文输入结束的时候会触发<code>compositionend</code>事件, 此时可以取到该输入框的完整的输入中文后的值(一般而言这个值是我们所需要的)</p>
<p>(额外的一点是从<code>input</code>事件开始可以拿到最新输入的值, 前面的事件拿到的值都要落后一次, 少了最后一次输入的字符)</p>
<p><code>change</code>事件的触发需要<strong>两个条件</strong>, 一是<code>input</code>元素即将失焦, 事件顺序是<code>change</code>=&gt;<code>blur</code>, 二是本次失焦后的内容与前一次失焦后的内容不同(如果相同是不会触发该事件的),</p>
<p>最常用的场景之一是<code>input</code>用来搜索的时候, 我们的需求是输入变化的时候就去查询(当然有节流), 但是在中文输入的时候就不要查询, 直到中文输入结束之后再查询, 这样可以避免用一些明显无效的关键词如<code>文章n'r</code>去查询, 等到完整中文输入后变成<code>文章内容</code>再去查询</p>
<pre><code class="language-js">function throttle(fn, minDelay, maxDelay) {
  let timer;
  let startTime = new Date();
  return function () {
    const context = this;
    const args = arguments;
    let curTime = new Date();
    clearTimeout(timer);
    if (curTime - startTime &gt;= maxDelay) {
      fn.apply(context, args);
      startTime = curTime;
    } else {
      timer = setTimeout(() =&gt; {
        fn.apply(context, args);
      }, minDelay);
    }
  }
}

function listenInput(selector, cb, delay = 150, maxDelay = 1000) {
  const el = document.querySelector(selector);
  if(!el || !cb || typeof cb !== 'function') {
    return false;
  }
  const throttleCB = throttle(cb, delay, maxDelay);
  let isComposition = false;
  const compositionstart = () =&gt; isComposition = true;
  const compositionend = () =&gt; {
    isComposition = false;
    throttleCB(el.value);
  };
  const input = () =&gt; {
    if(isComposition) {
      return false;
    }
    throttleCB(el.value);
  }

  el.addEventListener('compositionstart', compositionstart);
  el.addEventListener('compositionend', compositionend);
  el.addEventListener('input', input);
  
  return () =&gt; {
    el.removeEventListener('compositionstart', compositionstart);
    el.removeEventListener('compositionend', compositionend);
    el.removeEventListener('input', input);
  }
}

// 使用示例
// 开始监听, 默认最小间隔时间是150ms, 最大间隔时间是1000ms
const removeListener = listenInput('#inputId', value =&gt; {
  console.log(value);
}, 100, 1500);

// 取消监听
removeListener();
</code></pre>

        </div>
      </div>
    </div>
  </div>
  <script src="https://oss.kricsleo.com/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <script src="index.js"></script>
</body>
</html>