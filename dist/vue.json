{"path":"vue","title":"","summary":"vue$slots与$scopedSlots在2.5与2.6之间的父子组件重复渲染验证https://github.com/vuejs/rfcs/blob/master/active-rfcs/000","text":"vue$slots与$scopedSlots在2.5与2.6之间的父子组件重复渲染验证https://github.com/vuejs/rfcs/blob/master/active-rfcs/0006-slots-unification.md#summary vue关于$slots和$scopedSlots迁移计划这段话的pr讨论https://github.com/vuejs/vue/pull/9371 以及对比demo： 2.5版本：https://codesandbox.io/s/vue25-slots-vs-scopedslots-jsrn8?file=/src/components/HelloWorld.vue2.6版本：https://codesandbox.io/s/vue26-slots-vs-scopedslots-cu8rq?file=/src/components/HelloWorld.vue结论: 后续3.x版本中会统一使用$scopedSlots, 2.x中的$slots将被废弃, 这是一个迁移计划. 所以在日常2.x使用中统一使用$scopedSlots, 不要再使用$slots, 这样之后向3.x版本迁移的话可以借助工具一次性把代码都迁移到新的用法上为什么要通过组件触发事件外面注册回调的方式来执行函数,而不通过属性的方式把要调用的函数传递给组件让组件调用?对于dom原生事件的支持以及一些vue提供的事件修饰符(.stop等), 这类型的事件因为是dom原生的所以肯定是事件形式, 这种不必讨论.once修饰符可以针对非原生事件也起作用, 但是如果是函数属性的方式那么每次都会调用, 不支持.once的形式(以上两点都是针对修饰符在谈好处)作用域: 由于vue对于methods会自动绑定this, 所以函数实际执行时的作用域这一点上没有差别事件与函数最大的区别就在于事件是可以注册多个监听器的, 这对于代码的解耦是很有帮助的, 我们可以注册监听器a执行log等操作, 注册监听器b执行track等操作等等, 各部分逻辑是独立的, 但是如果是函数的话那么所有代码都必须统一写在这个函数里, 因为函数方式在被调用时只会有一个.在vue里面更具体的说就是: 加入你现在生成了一个vue实例, 你可以通过$on的方式注册多个事件监听器来执行不同的逻辑, 但是如果是函数属性的方式, 那么就只能传入一个函数给组件调用结论: 如果是不关系修饰符和注册多个监听器的场景的话可以使用函数属性的方式, 好处是属性是可以提前声明的, 这对于组件的使用者来说是很友好的, 可以通过查看你的属性声明来知道函数的参数以及返回值等, 尤其是配合ts时可以自动生成组件api文档, 比起别人在你的源码里面翻找$emit是如何触发的, 传递了什么参数要友好的多vuex和vue-router的黑魔法vue本身从起点new Vue(options)开始便留了口子, 传入的参数options会被合并存储在根实例的$options参数中, vue-router(vuex没看, 应该差不多)正是利用这一点通过初始化时在options中传入router对象, 之后所以的子实例通过一层层向上遍历找到根实例上的router然后来调用router的一些方法.(这也就是为什么自己有时候在一些特殊组件中使用new Vue()自己构建实例的时候拿不到router和vuex相关对象, 因为你自己new出来的实例自己就是根节点, 无法再向上查到到最外部的被注入了相关属性那个根实例, 当然你也可以在自己new的过程中把router和vuex注入进去, 这样你自己根节点下的实例中就也能向上遍历找到你本次注入的router和vuex)这有个启发, 之后如果想做一些类似的在所有实例注入一些东西, 是不是也可以通过options参数来注入?","html":"<h1>vue</h1>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\" checked=\"\"/>\n<p>$slots与$scopedSlots在2.5与2.6之间的父子组件重复渲染验证</p>\n<p>https://github.com/vuejs/rfcs/blob/master/active-rfcs/0006-slots-unification.md#summary vue关于$slots和$scopedSlots迁移计划</p>\n<p>这段话的pr讨论https://github.com/vuejs/vue/pull/9371 以及对比demo： </p>\n<ul>\n<li>2.5版本：https://codesandbox.io/s/vue25-slots-vs-scopedslots-jsrn8?file=/src/components/HelloWorld.vue</li>\n<li>2.6版本：https://codesandbox.io/s/vue26-slots-vs-scopedslots-cu8rq?file=/src/components/HelloWorld.vue</li>\n</ul>\n<p>结论: 后续3.x版本中会统一使用$scopedSlots, 2.x中的$slots将被废弃, 这是一个迁移计划. 所以在日常2.x使用中统一使用$scopedSlots, 不要再使用$slots, 这样之后向3.x版本迁移的话可以借助工具一次性把代码都迁移到新的用法上</p>\n</li>\n<li><input disabled=\"\" type=\"checkbox\" checked=\"\"/>\n<p>为什么要通过组件触发事件外面注册回调的方式来执行函数,而不通过属性的方式把要调用的函数传递给组件让组件调用?</p>\n<ul>\n<li>\n<p>对于dom原生事件的支持以及一些vue提供的事件修饰符(<code>.stop</code>等), 这类型的事件因为是dom原生的所以肯定是事件形式, 这种不必讨论</p>\n</li>\n<li>\n<p><code>.once</code>修饰符可以针对非原生事件也起作用, 但是如果是函数属性的方式那么每次都会调用, 不支持<code>.once</code>的形式(以上两点都是针对修饰符在谈好处)</p>\n</li>\n<li>\n<p>作用域: 由于vue对于methods会自动绑定this, 所以函数实际执行时的作用域这一点上没有差别</p>\n</li>\n<li>\n<p>事件与函数最大的区别就在于事件是可以注册多个监听器的, 这对于代码的解耦是很有帮助的, 我们可以注册监听器a执行log等操作, 注册监听器b执行track等操作等等, 各部分逻辑是独立的, 但是如果是函数的话那么所有代码都必须统一写在这个函数里, 因为函数方式在被调用时只会有一个.</p>\n<p>在vue里面更具体的说就是: 加入你现在生成了一个vue实例, 你可以通过<code>$on</code>的方式注册多个事件监听器来执行不同的逻辑, 但是如果是函数属性的方式, 那么就只能传入一个函数给组件调用</p>\n</li>\n</ul>\n<p>结论: 如果是不关系修饰符和注册多个监听器的场景的话可以使用函数属性的方式, 好处是属性是可以提前声明的, 这对于组件的使用者来说是很友好的, 可以通过查看你的属性声明来知道函数的参数以及返回值等, 尤其是配合ts时可以自动生成组件api文档, 比起别人在你的源码里面翻找<code>$emit</code>是如何触发的, 传递了什么参数要友好的多</p>\n</li>\n<li><input disabled=\"\" type=\"checkbox\" checked=\"\"/>\n<p>vuex和vue-router的黑魔法</p>\n<p><code>vue</code>本身从起点<code>new Vue(options)</code>开始便留了口子, 传入的参数<code>options</code>会被合并存储在根实例的<code>$options</code>参数中,<code> vue-router</code>(<code>vuex</code>没看, 应该差不多)正是利用这一点通过初始化时在<code>options</code>中传入<code>router</code>对象, 之后所以的子实例通过一层层向上遍历找到根实例上的<code>router</code>然后来调用<code>router</code>的一些方法.</p>\n<p>(这也就是为什么自己有时候在一些特殊组件中使用<code>new Vue()</code>自己构建实例的时候拿不到<code>router</code>和<code>vuex</code>相关对象, 因为你自己<code>new</code>出来的实例自己就是根节点, 无法再向上查到到最外部的被注入了相关属性那个根实例, 当然你也可以在自己<code>new</code>的过程中把<code>router</code>和<code>vuex</code>注入进去, 这样你自己根节点下的实例中就也能向上遍历找到你本次注入的<code>router</code>和<code>vuex</code>)</p>\n<p><strong>这有个启发, 之后如果想做一些类似的在所有实例注入一些东西, 是不是也可以通过<code>options</code>参数来注入?</strong></p>\n</li>\n</ul>\n","c_time":"2021-11-18 03:05:44","m_time":"2021-11-18 03:05:44"}